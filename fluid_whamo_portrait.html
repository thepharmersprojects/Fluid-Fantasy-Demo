<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Fluid Fantasy — Wham‑O Replica (Portrait)</title>
<style>
  :root {
    --bg:#0b0d10;
    --glass: rgba(214, 44, 44, 0.9); /* red acrylic */
    --frame:#ffffff;
    --oil:#186ad7; /* blue oil */
  }
  html, body { margin:0; padding:0; height:100%; background:var(--bg); overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; }
  #chrome {
    position:fixed; inset:0; pointer-events:none;
  }
  #bezel {
    position:absolute; left:0; top:0; right:0; bottom:0;
    border:10px solid var(--frame); border-radius:28px; box-sizing:border-box;
    pointer-events:none;
  }
  #glass {
    position:absolute; inset:0;
    background: var(--glass);
    border-radius:20px;
    margin:12px;
    pointer-events:none;
  }
  #ui {
    position:fixed; top:10px; left:10px; right:10px;
    display:flex; justify-content:space-between; gap:8px; z-index:4;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .btn {
    pointer-events:auto;
    background:#ffffff18; color:#fff; border:1px solid #ffffff35;
    padding:8px 10px; border-radius:10px; font-size:14px;
    backdrop-filter: blur(4px);
  }
  #hint {
    position:fixed; bottom:10px; left:10px; right:10px; z-index:4;
    color:#fff; text-align:center; font-size:13px; opacity:.85;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    text-shadow:0 1px 0 rgba(0,0,0,.5);
  }
  #landscapeOverlay {
    position:fixed; inset:0; background:#000c; color:#fff; display:none;
    align-items:center; justify-content:center; text-align:center; z-index:10;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="chrome" aria-hidden="true">
  <div id="glass"></div>
  <div id="bezel"></div>
</div>

<div id="ui">
  <button id="fsEnter" class="btn">Enter Fullscreen</button>
  <div style="flex:1"></div>
  <button id="fsExit" class="btn" style="display:none">Exit</button>
  <button id="reset" class="btn">Reset</button>
</div>
<div id="hint">Wham‑O style • Tilt to flow • Double‑tap to flip</div>

<div id="landscapeOverlay"><div>Rotate to portrait</div></div>

<script>
(function(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const dpr = Math.min(2, devicePixelRatio||1);
  let W=0, H=0;

  function resize() {
    const vw = Math.floor(window.innerWidth), vh = Math.floor(window.innerHeight);
    const w = vw, h = vh;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    W = w; H = h;
    layoutGeometry();
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // Portrait overlay
  const landscapeOverlay = document.getElementById('landscapeOverlay');
  function checkOrientation(){
    if (window.innerWidth > window.innerHeight) {
      landscapeOverlay.style.display = 'flex';
    } else {
      landscapeOverlay.style.display = 'none';
    }
  }
  window.addEventListener('resize', checkOrientation, {passive:true});
  checkOrientation();

  // Capsule geometry = full screen minus bezel margin
  const bezel = { x: 12, y: 12, r: 20 };
  let inner = { x: 0, y: 0, w: 0, h: 0, r: 16 };
  function layoutGeometry(){
    inner.x = bezel.x + 6;
    inner.y = bezel.y + 6;
    inner.w = W - (bezel.x + 6)*2;
    inner.h = H - (bezel.y + 6)*2;
  }

  // Rounded rect path
  function rrect(g, b){
    g.beginPath();
    const x=b.x, y=b.y, w=b.w, h=b.h, r=b.r;
    g.moveTo(x+r, y);
    g.arcTo(x+w, y, x+w, y+h, r);
    g.arcTo(x+w, y+h, x, y+h, r);
    g.arcTo(x, y+h, x, y, r);
    g.arcTo(x, y, x+w, y, r);
    g.closePath();
  }

  // Obstacles (white bars & nubs), proportionally placed
  const bars = [];
  function seedBars(){
    bars.length = 0;
    const {x,y,w,h} = inner;
    const thick = Math.max(6, Math.min(10, Math.round(w*0.012)));
    const push = (bx,by,bw,bh) => bars.push({x:bx, y:by, w:bw, h:bh, r:Math.min(thick,8)});
    // Bars roughly inspired by the Wham‑O art
    push(x+w*0.08, y+h*0.12, w*0.62, thick);
    push(x+w*0.26, y+h*0.24, w*0.56, thick);
    push(x+w*0.10, y+h*0.39, w*0.50, thick);
    push(x+w*0.20, y+h*0.55, w*0.68, thick);
    push(x+w*0.09, y+h*0.70, w*0.60, thick);
    // Nubs/pegs
    for (let i=0;i<6;i++){
      push(x+w*(0.20+0.12*i), y+h*(0.30 + (i%2)*0.10), thick*0.7, thick*2.4);
    }
  }
  seedBars();
  window.addEventListener('resize', seedBars, {passive:true});

  // Oil model: set of blobs with viscosity + surface tension attraction
  function Drop(x,y,r){ this.x=x; this.y=y; this.vx=0; this.vy=0; this.r=r; }
  const drops = [];
  function seedDrops(){
    drops.length=0;
    const {x,y,w,h} = inner;
    const N = 22; // fixed amount
    for (let i=0;i<N;i++){
      const rx = x + w*0.5 + (Math.random()*2-1)*w*0.2;
      const ry = y + h*0.20 + Math.random()*h*0.15;
      drops.push(new Drop(rx, ry, Math.max(14, 16 + Math.random()*10)));
    }
  }
  seedDrops();

  // Gravity via device tilt (+ double‑tap to flip)
  let gravityFlip = 1;
  let grav = {x:0, y:900};
  window.addEventListener('deviceorientation',(ev)=>{
    const gamma = (ev.gamma||0), beta=(ev.beta||0);
    grav.x = Math.sin(gamma*Math.PI/180)*900;
    grav.y = Math.sin(beta*Math.PI/180)*900;
  }, true);

  let lastTap=0;
  canvas.addEventListener('touchend', (e)=>{
    const now = Date.now();
    if (now-lastTap<300) gravityFlip *= -1;
    lastTap = now;
  }, {passive:true});

  // Collision helpers
  function collideCapsule(d){
    const pad = 8;
    const minX = inner.x + pad + d.r;
    const maxX = inner.x + inner.w - pad - d.r;
    const minY = inner.y + pad + d.r;
    const maxY = inner.y + inner.h - pad - d.r;
    if (d.x < minX){ d.x=minX; d.vx *= -0.5; }
    if (d.x > maxX){ d.x=maxX; d.vx *= -0.5; }
    if (d.y < minY){ d.y=minY; d.vy *= -0.5; }
    if (d.y > maxY){ d.y=maxY; d.vy *= -0.5; }
  }
  function collideBars(d){
    for (const b of bars){
      const nx = Math.max(b.x, Math.min(d.x, b.x+b.w));
      const ny = Math.max(b.y, Math.min(d.y, b.y+b.h));
      const dx = d.x - nx, dy = d.y - ny;
      if (dx*dx + dy*dy < d.r*d.r){
        // push out along shallowest axis
        const left = Math.abs(d.x - (b.x - d.r));
        const right = Math.abs((b.x + b.w + d.r) - d.x);
        const top = Math.abs(d.y - (b.y - d.r));
        const bottom = Math.abs((b.y + b.h + d.r) - d.y);
        const m = Math.min(left,right,top,bottom);
        if (m===left){ d.x=b.x-d.r; d.vx=-Math.abs(d.vx)*0.45; }
        else if (m===right){ d.x=b.x+b.w+d.r; d.vx=Math.abs(d.vx)*0.45; }
        else if (m===top){ d.y=b.y-d.r; d.vy=-Math.abs(d.vy)*0.45; }
        else { d.y=b.y+b.h+d.r; d.vy=Math.abs(d.vy)*0.45; }
      }
    }
  }

  // Oil physics: viscosity drag + weak cohesion (surface tension)
  const VISC = 0.985;            // velocity damping
  const MAXV = 900;              // clamp speed
  const COHERE_RANGE = 90;       // pixels
  const COHERE_STRENGTH = 25;    // attraction
  const MERGE_OVERLAP = 0.86;    // threshold to merge
  function update(dt){
    const gx = grav.x * gravityFlip, gy = grav.y * gravityFlip;
    for (let i=0;i<drops.length;i++){
      const d = drops[i];
      // cohesion
      let ax=0, ay=0;
      for (let j=0;j<drops.length;j++){
        if (i===j) continue;
        const o = drops[j];
        const dx = o.x - d.x, dy = o.y - d.y;
        const dist = Math.hypot(dx,dy);
        if (dist < COHERE_RANGE && dist > 1){
          const f = (COHERE_STRENGTH / dist);
          ax += dx * f;
          ay += dy * f;
        }
      }
      d.vx += (gx + ax) * dt;
      d.vy += (gy + ay) * dt;

      // viscosity + clamp
      d.vx *= VISC;
      d.vy *= VISC;
      const sp = Math.hypot(d.vx,d.vy);
      if (sp>MAXV){ d.vx *= MAXV/sp; d.vy *= MAXV/sp; }

      d.x += d.vx * dt;
      d.y += d.vy * dt;

      collideCapsule(d);
      collideBars(d);
    }

    // merge (area‑preserving)
    for (let i=0;i<drops.length;i++){
      const a = drops[i];
      for (let j=i+1;j<drops.length;j++){
        const b = drops[j];
        const dist = Math.hypot(a.x-b.x, a.y-b.y);
        if (dist < (a.r + b.r) * MERGE_OVERLAP){
          const area = Math.PI*a.r*a.r + Math.PI*b.r*b.r;
          const rNew = Math.sqrt(area/Math.PI);
          const vx = (a.vx + b.vx) * 0.5, vy = (a.vy + b.vy) * 0.5;
          const wA=a.r*a.r, wB=b.r*b.r, w=wA+wB;
          a.x = (a.x*wA + b.x*wB)/w;
          a.y = (a.y*wA + b.y*wB)/w;
          a.vx = vx; a.vy = vy; a.r = rNew;
          drops.splice(j,1); j--;
        }
      }
    }

    // occasional breakup when moving fast upward (imitates droplets forming)
    for (let i=0;i<drops.length;i++){
      const d = drops[i];
      if (d.r > 28 && Math.abs(d.vy) > 500 && Math.random()<0.01){
        // split into 2
        const r1 = d.r * 0.7, r2 = Math.sqrt(d.r*d.r - r1*r1);
        const ang = Math.random()*Math.PI*2;
        const s = 110;
        drops.splice(i,1,
          new Drop(d.x + Math.cos(ang)*r2, d.y + Math.sin(ang)*r2, r1),
          new Drop(d.x - Math.cos(ang)*r2, d.y - Math.sin(ang)*r2, r2)
        );
        i--;
      }
    }
  }

  // metaball render clipped to inner rounded-rect
  function render(){
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg').trim() || '#0b0d10';
    ctx.fillRect(0,0,W,H);

    // clip to inner
    ctx.save();
    rrect(ctx, inner);
    ctx.clip();

    // offscreen field
    const off = document.createElement('canvas');
    off.width = W; off.height = H;
    const octx = off.getContext('2d', {willReadFrequently:true});
    const img = octx.createImageData(off.width, off.height);
    const data = img.data;
    const threshold = 0.95;
    const step = 2; // larger step = faster

    for (let y=0; y<off.height; y+=step){
      for (let x=0; x<off.width; x+=step){
        let field = 0;
        for (let k=0;k<drops.length;k++){
          const d = drops[k];
          const dx = x - d.x, dy = y - d.y;
          const dist2 = dx*dx + dy*dy + 1e-3;
          field += (d.r*d.r)/dist2;
        }
        if (field > threshold){
          for (let oy=0; oy<step && y+oy<off.height; oy++){
            let idx = ((y+oy)*off.width + x)*4;
            for (let ox=0; ox<step && x+ox<off.width; ox++){
              data[idx+0]=0x18; data[idx+1]=0x6a; data[idx+2]=0xd7; data[idx+3]=255;
              idx+=4;
            }
          }
        }
      }
    }
    octx.putImageData(img,0,0);
    ctx.drawImage(off,0,0);

    // white bars
    ctx.fillStyle = '#fff';
    for (const b of bars){
      rrect(ctx,b); ctx.fill();
    }
    ctx.restore();
  }

  // frame loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000); last=now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Fullscreen controls
  const fsEnter = document.getElementById('fsEnter');
  const fsExit = document.getElementById('fsExit');
  const resetBtn = document.getElementById('reset');
  resetBtn.addEventListener('click', seedDrops);

  function inFullscreen(){
    return document.fullscreenElement || document.webkitFullscreenElement;
  }
  function showFsButtons(){
    if (inFullscreen()){
      fsEnter.style.display='none'; fsExit.style.display='inline-block';
    } else {
      fsEnter.style.display='inline-block'; fsExit.style.display='none';
    }
  }
  showFsButtons();

  async function enterFS(){
    const el = document.documentElement;
    try{
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    }catch(e){}
    showFsButtons();
  }
  async function exitFS(){
    try{
      if (document.exitFullscreen) await document.exitFullscreen();
      else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
    }catch(e){}
    showFsButtons();
  }
  fsEnter.addEventListener('click', enterFS);
  fsExit.addEventListener('click', exitFS);
  document.addEventListener('fullscreenchange', showFsButtons);
  document.addEventListener('webkitfullscreenchange', showFsButtons);
})();
</script>
</body>
</html>
