<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Fluid Fantasy — Browser Demo</title>
<style>
  html, body { margin: 0; padding: 0; background: #0b0d10; height: 100%; overflow: hidden; touch-action: none; }
  #ui {
    position: fixed; left: 12px; bottom: 12px; right: 12px;
    display: flex; gap: 8px; flex-wrap: wrap; align-items: center;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .btn {
    background: #151a20; color: #e7e8ea; border: 1px solid #2a3138;
    border-radius: 10px; padding: 10px 12px; font-size: 14px; opacity: 0.9;
  }
  .btn:active { transform: translateY(1px); }
  .hint {
    color: #b7c2cc; font-size: 12px; opacity: 0.8; padding: 6px 10px;
    background: rgba(21,26,32,0.6); border: 1px solid #2a3138; border-radius: 10px;
  }
  #motionBtn { display: none; }
  #topbar {
    position: fixed; top: 12px; left: 12px; right: 12px; display: flex; justify-content: space-between; align-items: center;
    color: #e7e8ea; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    opacity: 0.9;
  }
  #title { font-weight: 700; letter-spacing: 0.5px; font-size: 14px; }
  #fps { font-variant-numeric: tabular-nums; font-size: 12px; opacity: 0.7; }
  canvas { display: block; width: 100vw; height: 100vh; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="topbar">
  <div id="title">Fluid Fantasy — Tilt to flow • Tap to add • Double‑tap to flip</div>
  <div id="fps"></div>
</div>
<div id="ui">
  <button id="motionBtn" class="btn">Enable Motion</button>
  <button id="resetBtn" class="btn">Reset</button>
  <div class="hint">If tilt doesn’t work on iPhone: tap <b>Enable Motion</b> and allow access.</div>
</div>

<script>
(function() {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W=0, H=0, scale=1;
  const dpr = Math.min(2, devicePixelRatio || 1);
  function resize() {
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    // Render at reduced internal resolution for performance, then scale up.
    scale = (W*H > 900*1600) ? 0.6 : 0.75;
    canvas.width = Math.floor(W * scale * dpr);
    canvas.height = Math.floor(H * scale * dpr);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(scale * dpr, scale * dpr);
  }
  window.addEventListener('resize', resize, { passive: true });
  resize();

  const fpsEl = document.getElementById('fps');
  let lastFpsTime = performance.now(), frames=0;

  // --- Physics model ---
  const fluidA = []; // lighter (e.g., oil) — orange
  const fluidB = []; // heavier (e.g., water) — teal
  function Drop(x,y,r) { this.x=x; this.y=y; this.vx= (Math.random()*2-1)*40; this.vy=(Math.random()*2-1)*40; this.r=r; }

  function seed() {
    fluidA.length=0; fluidB.length=0;
    const padX = W*scale*0.15, padY = H*scale*0.12;
    for (let i=0;i<12;i++) fluidA.push(new Drop(rand(padX, (W*scale)-padX), rand(padY, (H*scale)*0.4), rand(18, 32)));
    for (let i=0;i<12;i++) fluidB.push(new Drop(rand(padX, (W*scale)-padX), rand((H*scale)*0.6, (H*scale)-padY), rand(18, 32)));
  }
  function rand(a,b){ return a + Math.random()*(b-a); }
  seed();

  let g = { x: 0, y: 500 }; // px/s^2; will map to tilt; default "down"
  let gravityFlip = 1;

  // Device motion handling (iOS 13+ needs user gesture to allow)
  const motionBtn = document.getElementById('motionBtn');
  const resetBtn = document.getElementById('resetBtn');
  resetBtn.addEventListener('click', ()=> seed());

  function needMotionPermission() {
    return typeof DeviceMotionEvent !== 'undefined' &&
           typeof DeviceMotionEvent.requestPermission === 'function';
  }
  function showMotionButton() { motionBtn.style.display = 'inline-block'; }
  function hideMotionButton() { motionBtn.style.display = 'none'; }

  if (needMotionPermission()) {
    showMotionButton();
    motionBtn.addEventListener('click', async () => {
      try {
        const res = await DeviceMotionEvent.requestPermission();
        if (res === 'granted') {
          hideMotionButton();
        }
      } catch(e) { console.warn(e); }
    });
  }

  window.addEventListener('deviceorientation', (ev) => {
    // gamma: left-right [-90..90], beta: front-back [-180..180]
    const gamma = (ev.gamma || 0);
    const beta  = (ev.beta  || 0);
    // Map to gravity. Tune multipliers for feel.
    const gx = Math.sin(gamma * Math.PI/180) * 500;
    const gy = Math.sin(beta  * Math.PI/180) * 500;
    g.x = gx; g.y = gy;
  }, true);

  // Double-tap to flip gravity direction (for devices without motion)
  let lastTap = 0;
  canvas.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTap < 300) {
      gravityFlip *= -1;
    }
    lastTap = now;
  }, { passive: true });

  // Tap / click to add droplets
  function addDrops(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * scale;
    const y = (clientY - rect.top) * scale;
    for (let k=0;k<2;k++) fluidA.push(new Drop(x + (Math.random()*20-10), y-30 + (Math.random()*20-10), rand(14,24)));
    for (let k=0;k<2;k++) fluidB.push(new Drop(x + (Math.random()*20-10), y+30 + (Math.random()*20-10), rand(14,24)));
  }
  canvas.addEventListener('pointerdown', (e)=> { addDrops(e.clientX, e.clientY); });

  // --- Simulation update ---
  function update(ds, density=1.0, dt=0.016) {
    const gx = g.x * density * gravityFlip;
    const gy = g.y * density * gravityFlip;
    const damp = 0.995;
    const maxV = 1200;
    for (let i=0;i<ds.length;i++) {
      const d = ds[i];
      d.vx += gx * dt;
      d.vy += gy * dt;
      // clamp velocity
      const sp = Math.hypot(d.vx, d.vy);
      if (sp > maxV) { d.vx *= maxV/sp; d.vy *= maxV/sp; }
      d.vx *= damp; d.vy *= damp;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      // boundaries
      const minX = d.r, maxX = W*scale - d.r;
      const minY = d.r, maxY = H*scale - d.r;
      if (d.x < minX) { d.x=minX; d.vx*=-0.6; }
      if (d.x > maxX) { d.x=maxX; d.vx*=-0.6; }
      if (d.y < minY) { d.y=minY; d.vy*=-0.6; }
      if (d.y > maxY) { d.y=maxY; d.vy*=-0.6; }
    }
  }

  function merge(ds) {
    // O(N^2) simple merge; fine for small droplet counts
    for (let i=0;i<ds.length;i++) {
      const a = ds[i];
      for (let j=i+1;j<ds.length;j++) {
        const b = ds[j];
        const dx=a.x-b.x, dy=a.y-b.y;
        const dist = Math.hypot(dx,dy);
        if (dist < (a.r + b.r)*0.9) {
          // conserve area (pi r^2)
          const area = Math.PI*a.r*a.r + Math.PI*b.r*b.r;
          const rNew = Math.sqrt(area/Math.PI);
          // momentum average
          const vx = (a.vx + b.vx)*0.5;
          const vy = (a.vy + b.vy)*0.5;
          // place at weighted center
          const wA = a.r*a.r, wB = b.r*b.r, wSum = wA + wB;
          const x = (a.x*wA + b.x*wB)/wSum;
          const y = (a.y*wA + b.y*wB)/wSum;
          a.x=x; a.y=y; a.vx=vx; a.vy=vy; a.r=rNew;
          ds.splice(j,1); j--;
        }
      }
    }
  }

  // --- Metaball rendering (CPU, downscaled) ---
  const off = document.createElement('canvas');
  const octx = off.getContext('2d', { willReadFrequently: true });
  function renderMetaballs(ds, fillStyle, threshold, step) {
    // render to offscreen pixel buffer for speed
    off.width = Math.floor(W*scale);
    off.height = Math.floor(H*scale);
    const img = octx.createImageData(off.width, off.height);
    const data = img.data;

    for (let y=0; y<off.height; y+=step) {
      for (let x=0; x<off.width; x+=step) {
        let field = 0;
        for (let k=0; k<ds.length; k++) {
          const d = ds[k];
          const dx = x - d.x, dy = y - d.y;
          const dist2 = dx*dx + dy*dy + 1e-3;
          field += (d.r*d.r) / dist2;
        }
        if (field > threshold) {
          // fill a small block for stride 'step'
          for (let oy=0; oy<step && y+oy<off.height; oy++) {
            let idx = ((y+oy) * off.width + x) * 4;
            for (let ox=0; ox<step && x+ox<off.width; ox++) {
              data[idx+0] = fillStyle[0];
              data[idx+1] = fillStyle[1];
              data[idx+2] = fillStyle[2];
              data[idx+3] = 255;
              idx += 4;
            }
          }
        }
      }
    }
    octx.putImageData(img, 0, 0);
    ctx.drawImage(off, 0, 0);
  }

  function hexToRgb(hex) {
    hex = hex.replace('#','');
    if (hex.length===3) hex = hex.split('').map(c=>c+c).join('');
    const num = parseInt(hex,16);
    return [ (num>>16)&255, (num>>8)&255, num&255 ];
  }

  const colTeal = hexToRgb('#1a948b');   // fluid B
  const colGold = hexToRgb('#eca72c');   // fluid A

  let last = performance.now();
  function frame(now) {
    const dt = Math.min(0.033, (now - last)/1000); // cap 30ms
    last = now;

    // Update physics (different buoyancy factors)
    update(fluidA, 0.6, dt);
    update(fluidB, 1.0, dt);
    merge(fluidA);
    merge(fluidB);

    // Clear
    ctx.fillStyle = '#0b0d10';
    ctx.fillRect(0,0, W*scale, H*scale);

    // Draw: heavier behind, lighter in front
    const threshold = 0.9, step = 2; // tune for speed/quality
    renderMetaballs(fluidB, colTeal, threshold, step);
    renderMetaballs(fluidA, colGold, threshold, step);

    // FPS
    frames++;
    if (now - lastFpsTime > 500) {
      fpsEl.textContent = (frames * 1000 / (now - lastFpsTime)).toFixed(0) + ' fps';
      lastFpsTime = now; frames = 0;
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Prevent iOS rubber-band scrolling
  document.addEventListener('touchmove', (e)=> e.preventDefault(), { passive: false });

})();
</script>
</body>
</html>
