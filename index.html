<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fluid Fantasy – Single Orifice Drip</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b1420; --face1:#c6352b; --face2:#a42e27; --stroke:#7b1f1a;
    --shelf:#eef1f6; --oil:#2c82ff; --edge:#16488f;
  }
  html,body{margin:0;background:var(--bg);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px}
  .wrap{width:min(420px,92vw)}
  .phone{position:relative;aspect-ratio:9/16;border-radius:28px;box-shadow:0 14px 40px rgba(0,0,0,.55), inset 0 0 0 10px #0e1724;background:linear-gradient(#1b2330,#0d1623);padding:18px}
  canvas{width:100%;height:100%;display:block;border-radius:22px}
  .panel{background:#0f1726;border:1px solid #1e2a42;border-radius:12px;padding:10px 12px;color:#cfd7e7}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin:6px 0}
  input[type=range]{width:52vw;max-width:440px}
  small{color:#a7b1c8}
</style>
</head>
<body>
  <div class="wrap phone"><canvas id="sim"></canvas></div>
  <div class="wrap panel">
    <div class="row"><label>Outlet size</label><input id="outlet" type="range" min="2" max="16" step="1" value="6"></div>
    <div class="row"><label>Tension (detach mass)</label><input id="tension" type="range" min="0" max="1" step="0.01" value="0.6"></div>
    <div class="row"><label>Viscosity (fall drag)</label><input id="visc" type="range" min="0" max="1" step="0.01" value="0.35"></div>
    <div class="row"><label>Sim tilt (◀︎/▶︎)</label><input id="tilt" type="range" min="-0.8" max="0.8" step="0.01" value="0"></div>
    <small>All oil is held at the top and drains only through the single opening as one drop at a time. No other drips form.</small>
  </div>

<script>
(() => {
  // ----- Canvas setup -----
  const cvs = document.getElementById('sim');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  let W=360, H=640;
  const pad = 20*DPR, rr = 20*DPR;
  function resize(){
    const b=cvs.getBoundingClientRect();
    W=Math.round(b.width*DPR); H=Math.round(b.height*DPR);
    cvs.width=W; cvs.height=H;
    world.init();
  }
  addEventListener('resize', resize);

  // ----- Controls -----
  const $out = document.getElementById('outlet');
  const $ten = document.getElementById('tension');
  const $vis = document.getElementById('visc');
  const $tilt= document.getElementById('tilt');

  // ----- World / model -----
  const world = {
    box: null,
    topShelf: null,
    outletX: 0,
    outletW: () => parseFloat($out.value)*DPR, // px
    reservoir: { // "cup" of oil above the shelf
      volume: 0,    // abstract units ~ px^2
      max: 0,
      head: 0       // height of fluid above shelf (px)
    },
    neck: { mass:0 }, // mass accumulating at the rim before drop detaches
    drops: [],
    bottomPool: 0,

    init(){
      this.box   = { x:pad, y:pad, w:W-2*pad, h:H-2*pad, r:rr };
      const sx = this.box.x+8*DPR, sy = this.box.y + this.box.h*0.16;
      const sw = this.box.w-16*DPR, sh = 8*DPR;
      this.topShelf = { x:sx, y:sy, w:sw, h:sh };

      // Outlet: centered small gap in the top shelf
      this.outletX = this.topShelf.x + this.topShelf.w/2;

      // Fill reservoir initially (a full band to the top edge)
      const topClearance = 10*DPR;
      const topY = this.box.y + topClearance;
      const shelfY = this.topShelf.y;
      this.reservoir.head = Math.max(10*DPR, (shelfY - topY)); // px
      this.reservoir.max  = (this.reservoir.head) * (this.topShelf.w); // area proxy
      this.reservoir.volume = this.reservoir.max*0.95; // slightly below brim to avoid overflow art
      this.neck.mass = 0;
      this.drops.length = 0;
      this.bottomPool = 0;
    }
  };

  // ----- Physics -----
  const DT = 1/60;
  const G  = 900*DPR;

  function gravityVec(){
    const tilt=parseFloat($tilt.value);
    const gx=tilt, gy=1; const m=Math.hypot(gx,gy);
    return {ax:G*gx/m, ay:G*gy/m};
  }

  function step(){
    // 1) Move oil from reservoir -> neck through outlet
    const visc = 0.05 + 1.2*parseFloat($vis.value); // drag for falling drops
    const tensionMul = 0.5 + 1.5*parseFloat($ten.value); // larger => needs more neck mass to detach
    const {ax,ay} = gravityVec();

    if (world.reservoir.volume > 0){
      // Simple Torricelli-like inflow to neck: rate ∝ outlet area * sqrt(head)
      const headPx = Math.max(0, world.reservoir.volume / world.topShelf.w); // approximate height from volume
      const A = Math.max(2*DPR, world.outletW()); // outlet "area" proxy
      const c = 0.35; // discharge coefficient
      const inflow = c * A * Math.sqrt(Math.max(0, headPx)) * DT; // area units per frame
      world.reservoir.volume = Math.max(0, world.reservoir.volume - inflow);
      world.neck.mass += inflow; // mass proxy uses same units
    }

    // Detach a drop only from the outlet when neck mass exceeds threshold
    const detachThresh = (120*DPR*DPR) * tensionMul;
    if (world.neck.mass > detachThresh){
      const r = Math.sqrt(world.neck.mass)*0.55; // radius from mass
      world.drops.push({
        x: world.outletX,
        y: world.topShelf.y + world.topShelf.h/2 + r,
        vx: ax*DT*5, // tiny horizontal impulse from tilt
        vy: ay*DT*5 + 40*DPR, // initial downward speed to clear the shelf
        r
      });
      world.neck.mass = 0; // reset the neck
    }

    // 2) Advance falling drops (no bounce)
    const wallL = world.box.x + 6*DPR;
    const wallR = world.box.x + world.box.w - 6*DPR;
    const floorY= world.box.y + world.box.h - 6*DPR;

    for (const d of world.drops){
      d.vx += ax*DT; d.vy += ay*DT;
      d.vx *= (1 - visc*DT); d.vy *= (1 - visc*DT);
      d.x += d.vx*DT; d.y += d.vy*DT;
      if (d.x<wallL){ d.x=wallL; d.vx=0; }
      if (d.x>wallR){ d.x=wallR; d.vx=0; }
      if (d.y>=floorY){
        world.bottomPool += d.r*d.r;
        d.r = 0; // mark for removal
      }
    }
    // cleanup
    for (let i=world.drops.length-1;i>=0;i--) if (world.drops[i].r<=0) world.drops.splice(i,1);
  }

  // ----- Drawing helpers -----
  function rrRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }
  function fillDevice(){
    const b=world.box;
    const g=ctx.createLinearGradient(0,b.y,0,b.y+b.h);
    g.addColorStop(0,'#d7443b'); g.addColorStop(1,'#a42e27');
    rrRect(ctx,b.x,b.y,b.w,b.h,b.r);
    ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=6*DPR; ctx.strokeStyle='#7b1f1a'; ctx.stroke();
  }
  function drawTopShelf(){
    const s=world.topShelf;
    const gap = world.outletW();
    const gapX = world.outletX - gap/2;
    const rr = s.h/2;

    ctx.save();
    ctx.fillStyle = getVar('--shelf');
    // left segment
    rrRect(ctx, s.x, s.y, (gapX - s.x), s.h, rr); ctx.fill();
    // right segment
    const rx = gapX + gap;
    rrRect(ctx, rx, s.y, (s.x + s.w - rx), s.h, rr); ctx.fill();
    ctx.restore();

    // neck visualization at the rim
    if (world.neck.mass>0){
      const oil=getVar('--oil'), edge=getVar('--edge');
      const r = Math.sqrt(world.neck.mass)*0.35;
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(world.outletX, s.y + s.h/2 + r*0.5, r*0.9, r*1.1, 0, 0, Math.PI*2);
      ctx.fillStyle=oil; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
      ctx.restore();
    }
  }
  function drawReservoir(){
    // draw the pool held above the shelf; its height shrinks with volume
    const s=world.topShelf;
    const oil=getVar('--oil'), edge=getVar('--edge');
    const area = world.reservoir.volume;
    if (area<=0) return;
    const height = Math.min(world.box.h*0.4, area / s.w); // px
    const topY = s.y - height;
    const x = s.x, y = topY, w = s.w, h = height;
    ctx.save();
    rrRect(ctx, x, y, w, h, 10*DPR);
    ctx.fillStyle=oil; ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=edge; ctx.stroke();
    ctx.restore();
  }
  function drawDrops(){
    const oil=getVar('--oil'), edge=getVar('--edge');
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=10*DPR;
    for(const d of world.drops){
      ctx.beginPath();
      ctx.ellipse(d.x, d.y, d.r*1.04, d.r*0.96, Math.atan2(d.vy,d.vx), 0, Math.PI*2);
      ctx.fillStyle=oil; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
    }
    ctx.restore();
  }
  function drawBottomPool(){
    if(world.bottomPool<=0) return;
    const oil=getVar('--oil'), edge=getVar('--edge');
    const area=world.bottomPool*0.004;
    const level=Math.min(world.box.h*0.35, area/world.box.w);
    const x=world.box.x+6*DPR, y=world.box.y+world.box.h-level-6*DPR, w=world.box.w-12*DPR, h=level;
    rrRect(ctx,x,y,w,h,10*DPR); ctx.fillStyle=oil; ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=edge; ctx.stroke();
  }
  function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  // ----- Main loop -----
  resize();
  let last=performance.now();
  function frame(t){
    let acc=(t-last)/1000; last=t;
    while(acc>DT){ step(); acc-=DT; }

    ctx.clearRect(0,0,W,H);
    fillDevice();
    drawTopShelf();
    drawBottomPool();
    drawDrops();
    drawReservoir();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // Reinitialize when outlet size changes (keeps it simple)
  $out.addEventListener('input', ()=>world.init());
})();
</script>
</body>
</html>
