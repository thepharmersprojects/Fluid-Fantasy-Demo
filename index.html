<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fluid Fantasy – Slosh + Necking Drops</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b1420;
    --face1:#c6352b; --face2:#a42e27; --stroke:#7b1f1a;
    --shelf:#eef1f6;
    --oil:#64a8ff;        /* light center */
    --oil-edge:#0f3c89;   /* dark rim */
  }
  html,body{margin:0;background:var(--bg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px}
  .wrap{width:min(430px,92vw)}
  .phone{position:relative;aspect-ratio:9/16;background:linear-gradient(#1a2230,#0c1422);border-radius:28px;box-shadow:0 14px 40px rgba(0,0,0,.55), inset 0 0 0 10px #0e1724;padding:18px}
  canvas{width:100%;height:100%;display:block;border-radius:22px}
  .panel{background:#0f1726;border:1px solid #1e2a42;border-radius:12px;padding:10px 12px;color:#cfd7e7}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin:6px 0}
  input[type=range]{width:52vw;max-width:440px}
  small{color:#9fb0cf}
</style>
</head>
<body>
  <div class="wrap phone"><canvas id="sim"></canvas></div>
  <div class="wrap panel">
    <div class="row"><label>Outlet size</label><input id="out" type="range" min="2" max="20" step="1" value="8"></div>
    <div class="row"><label>Tension (detach mass)</label><input id="ten" type="range" min="0" max="1" step="0.01" value="0.6"></div>
    <div class="row"><label>Viscosity (drag)</label><input id="vis" type="range" min="0" max="1" step="0.01" value="0.35"></div>
    <div class="row"><label>Sim Tilt (◀︎ / ▶︎)</label><input id="tilt" type="range" min="-0.9" max="0.9" step="0.01" value="0"></div>
    <small>Top reservoir sloshes and empties only through the outlet. Drops form by necking, fall as tear-drops, and spread at the bottom. No bounce. Volume conserved.</small>
  </div>

<script>
(() => {
  // ===== Canvas/setup =====
  const cvs = document.getElementById('sim');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  let W=360, H=640;
  const pad = 20*DPR, rr = 20*DPR;

  const $out = document.getElementById('out');
  const $ten = document.getElementById('ten');
  const $vis = document.getElementById('vis');
  const $tilt= document.getElementById('tilt');

  function resize(){
    const b=cvs.getBoundingClientRect();
    W=Math.round(b.width*DPR); H=Math.round(b.height*DPR);
    cvs.width=W; cvs.height=H;
    world.init();
  }
  addEventListener('resize', resize);

  // ===== World =====
  const world = {
    box:null, shelf:null, outletX:0,
    NX: 120,             // horizontal resolution for heightfields
    resH:[],             // top reservoir heightfield (px)
    poolH:[],            // bottom pool heightfield (px)
    dx:1,                // cell width in px (computed on init)
    outW(){ return parseFloat($out.value)*DPR; },

    // neck (growing ligament at rim)
    neck:{ mass:0, len:0, radius:0 },
    drops:[],
    init(){
      this.box = {x:pad, y:pad, w:W-2*pad, h:H-2*pad, r:rr};
      const sx = this.box.x+8*DPR, sy=this.box.y+this.box.h*0.16, sw=this.box.w-16*DPR, sh=8*DPR;
      this.shelf = {x:sx, y:sy, w:sw, h:sh};
      this.outletX = this.shelf.x + this.shelf.w/2;
      // heightfields
      this.dx = this.shelf.w/this.NX;
      this.resH = new Array(this.NX).fill(this.shelf.y - (this.box.y+10*DPR)); // head above shelf
      this.poolH = new Array(this.NX).fill(0);
      // clip reservoir edges to container corners (meniscus hint)
      for(let i=0;i<6;i++){ this.resH[i]*=0.6; this.resH[this.NX-1-i]*=0.6; }
      this.neck.mass=0; this.neck.len=0; this.neck.radius=0;
      this.drops.length=0;
    }
  };

  // ===== Physics =====
  const DT = 1/60, G=900*DPR;
  function gvec(){
    const t=parseFloat($tilt.value);
    const gx=t, gy=1; const m=Math.hypot(gx,gy);
    return {ax:G*gx/m, ay:G*gy/m};
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // simple 1-D shallow-water-ish slosh: flow ~ slope + tilt bias
  function slosh(Harr, bias, k=0.18){
    const N=Harr.length;
    const out=new Array(N).fill(0);
    for(let i=0;i<N-1;i++){
      const slope = (Harr[i]-Harr[i+1]);
      const f = k*(slope + bias); // bias pushes "downhill" with tilt
      out[i]   -= f;
      out[i+1] += f;
    }
    // apply and clamp >=0
    for(let i=0;i<N;i++){
      Harr[i] = Math.max(0, Harr[i] + out[i]);
    }
  }

  function step(){
    const visc = 0.05 + 1.2*parseFloat($vis.value);
    const tenMul = 0.6 + 1.5*parseFloat($ten.value);
    const {ax,ay} = gvec();
    const bias = ax * 0.35; // horizontal slosh driver (kept small—gravity is always down)

    // 1) Slosh reservoir & bottom pool to match tilt / container
    slosh(world.resH, bias, 0.22);
    slosh(world.poolH, bias, 0.35); // bottom spreads faster

    // 2) Outlet transfer (Torricelli-like), one cell at the outlet
    const iOut = Math.floor((world.outletX - world.shelf.x)/world.dx);
    const head = world.resH[iOut]; // px of fluid above shelf at the outlet cell
    if (head>0){
      const A = Math.max(2*DPR, world.outW()); // "area" proxy
      const c = 0.35; // discharge coefficient
      const flow = c * A * Math.sqrt(head) * DT; // area per frame
      // Convert to "height" removed from that cell:
      const dH = flow / world.dx;
      world.resH[iOut] = Math.max(0, world.resH[iOut] - dH);
      // Grow neck (mass reservoir at rim)
      world.neck.mass += flow;
      // Neck geometry grows gradually, not instantly circular
      world.neck.len   = clamp(world.neck.len + 0.9*DT*DPR + Math.sqrt(head)*0.02, 2*DPR, 36*DPR);
      world.neck.radius= clamp(world.neck.radius + 0.6*DT*DPR, 2*DPR, 14*DPR);
    } else {
      // if starved, the ligament thins back a bit
      world.neck.len   = Math.max(0, world.neck.len - 10*DT);
      world.neck.radius= Math.max(1*DPR, world.neck.radius - 14*DT);
    }

    // 3) Detach when neck mass exceeds threshold (surface tension)
    const detachThresh = (140*DPR*DPR) * tenMul;
    if (world.neck.mass > detachThresh){
      const r = Math.sqrt(world.neck.mass)*0.52;
      world.drops.push({
        x: world.outletX, y: world.shelf.y + world.shelf.h/2 + world.neck.len + r*0.2,
        vx: ax*DT*12, vy: 40*DPR,
        r
      });
      world.neck.mass = 0;
      world.neck.len  = world.neck.radius*0.4; // leave a short ligament that immediately regrows
    }

    // 4) Advance drops (tear-drop, no bounce). On impact, add volume to bottom pool and spread.
    const wallL = world.box.x+6*DPR, wallR = world.box.x+world.box.w-6*DPR;
    const floorY= world.box.y+world.box.h-6*DPR;

    for (const d of world.drops){
      d.vx += ax*DT; d.vy += ay*DT;
      d.vx *= (1 - visc*DT); d.vy *= (1 - visc*DT);
      d.x += d.vx*DT; d.y += d.vy*DT;
      if (d.x<wallL){ d.x=wallL; d.vx=0; }
      if (d.x>wallR){ d.x=wallR; d.vx=0; }

      if (d.y >= floorY){
        // Add volume to pool heightfield at impact column (then it will slosh/spread)
        const i = clamp(Math.floor((d.x - world.shelf.x)/world.dx), 0, world.NX-1);
        const vol = d.r*d.r;              // area proxy
        world.poolH[i] += vol / world.dx; // convert to height
        d.r = 0; // remove
      }
    }
    for (let i=world.drops.length-1;i>=0;i--) if(world.drops[i].r<=0) world.drops.splice(i,1);
  }

  // ===== Drawing =====
  function rrRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }
  function getVar(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}

  function drawDevice(){
    const b=world.box;
    const g=ctx.createLinearGradient(0,b.y,0,b.y+b.h);
    g.addColorStop(0,'#d7443b'); g.addColorStop(1,'#a42e27');
    rrRect(ctx,b.x,b.y,b.w,b.h,b.r); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=6*DPR; ctx.strokeStyle='#7b1f1a'; ctx.stroke();
  }
  function drawShelf(){
    const s=world.shelf, rr=s.h/2, gap=world.outW(), gapX=world.outletX-gap/2;
    ctx.save(); ctx.fillStyle=getVar('--shelf');
    rrRect(ctx,s.x, s.y, gapX-s.x, s.h, rr); ctx.fill();
    rrRect(ctx,gapX+gap, s.y, s.x+s.w-(gapX+gap), s.h, rr); ctx.fill();
    ctx.restore();
  }

  // reservoir polygon from heightfield (dark edge, light center)
  function drawReservoir(){
    const s=world.shelf, x0=s.x, topY = y=> s.y - y;
    // Compute path
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x0, s.y);
    for(let i=0;i<world.NX;i++){
      const x = x0 + i*world.dx;
      ctx.lineTo(x, topY(world.resH[i]));
    }
    ctx.lineTo(x0 + world.NX*world.dx, s.y);
    ctx.closePath();
    // Fill with edge-dark gradient (approx: stroke dark, fill light)
    ctx.fillStyle=getVar('--oil'); ctx.fill();
    ctx.lineWidth=4*DPR; ctx.strokeStyle=getVar('--oil-edge'); ctx.stroke();
    ctx.restore();

    // draw neck (ligament) if present
    if (world.neck.len>1){
      const cx = world.outletX, cy = s.y + s.h/2;
      const len = world.neck.len, r = Math.max(1*DPR, world.neck.radius);
      // bezier "cone" to a bulb
      ctx.save();
      ctx.strokeStyle=getVar('--oil-edge'); ctx.lineWidth=2*DPR;
      ctx.fillStyle=getVar('--oil');
      ctx.beginPath();
      ctx.moveTo(cx - r*0.45, cy);
      ctx.bezierCurveTo(cx - r*0.35, cy + len*0.35, cx - r*0.2, cy + len*0.75, cx, cy + len);
      ctx.bezierCurveTo(cx + r*0.2, cy + len*0.75, cx + r*0.35, cy + len*0.35, cx + r*0.45, cy);
      ctx.closePath(); ctx.fill(); ctx.stroke();

      // bulb at the end of the neck (not perfect circle)
      ctx.beginPath();
      ctx.ellipse(cx, cy + len + r*0.8, r*1.05, r*0.85, 0, 0, Math.PI*2);
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  }

  // bottom pool from heightfield (spreads & hugs corners; edge dark, center light)
  function drawBottomPool(){
    const b=world.box, x0=world.shelf.x, base=b.y+b.h-6*DPR;
    // If empty, skip
    let sum=0; for(const h of world.poolH) sum+=h; if(sum<=0) return;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x0, base);
    for(let i=0;i<world.NX;i++){
      const x = x0 + i*world.dx;
      ctx.lineTo(x, base - world.poolH[i]);
    }
    ctx.lineTo(x0 + world.NX*world.dx, base);
    ctx.closePath();

    // Fill center light, edge dark effect
    const lg = ctx.createLinearGradient(x0,0,x0+world.NX*world.dx,0);
    lg.addColorStop(0, getVar('--oil-edge'));
    lg.addColorStop(0.15, getVar('--oil'));
    lg.addColorStop(0.85, getVar('--oil'));
    lg.addColorStop(1, getVar('--oil-edge'));
    ctx.fillStyle = lg; ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=getVar('--oil-edge'); ctx.stroke();
    ctx.restore();
  }

  function drawDrops(){
    const center=getVar('--oil'), edge=getVar('--oil-edge');
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=10*DPR;
    for(const d of world.drops){
      // oriented tear-drop (never a perfect circle unless vy≈vx≈0)
      const ang = Math.atan2(d.vy, d.vx);
      ctx.beginPath();
      ctx.ellipse(d.x, d.y, d.r*1.12, d.r*0.9, ang, 0, Math.PI*2);
      // radial gradient: light center, dark rim
      const g = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.r*1.2);
      g.addColorStop(0, center);
      g.addColorStop(1, edge);
      ctx.fillStyle=g; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
    }
    ctx.restore();
  }

  // ===== Main loop =====
  resize();
  let last=performance.now();
  function frame(t){
    let acc=(t-last)/1000; last=t;
    while(acc>DT){ step(); acc-=DT; }
    ctx.clearRect(0,0,W,H);
    drawDevice();
    drawShelf();
    drawBottomPool();
    drawDrops();
    drawReservoir();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
