<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fluid Fantasy — Attached Neck + Strict Volume</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b1420;
    --chassis1:#c6352b; --chassis2:#a42e27; --chassisStroke:#7b1f1a;
    --shelf:#eef1f6;
    --oilCenter:#64a8ff;   /* light center */
    --oilEdge:#0f3c89;     /* dark rim */
  }
  html,body{margin:0;background:var(--bg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px}
  .wrap{width:min(430px,92vw)}
  .phone{position:relative;aspect-ratio:9/16;background:linear-gradient(#1a2230,#0c1422);border-radius:28px;box-shadow:0 14px 40px rgba(0,0,0,.55), inset 0 0 0 10px #0e1724;padding:18px}
  canvas{width:100%;height:100%;display:block;border-radius:22px}
  .panel{background:#0f1726;border:1px solid #1e2a42;border-radius:12px;padding:10px 12px;color:#cfd7e7}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin:6px 0}
  input[type=range]{width:52vw;max-width:440px}
  small{color:#9fb0cf}
</style>
</head>
<body>
  <div class="wrap phone"><canvas id="sim"></canvas></div>
  <div class="wrap panel">
    <div class="row"><label>Outlet size</label><input id="out" type="range" min="2" max="20" step="1" value="8"></div>
    <div class="row"><label>Tension (detach mass)</label><input id="ten" type="range" min="0" max="1" step="0.01" value="0.6"></div>
    <div class="row"><label>Viscosity (fall drag)</label><input id="vis" type="range" min="0" max="1" step="0.01" value="0.35"></div>
    <div class="row"><label>Sim Tilt (◀︎ / ▶︎)</label><input id="tilt" type="range" min="-0.9" max="0.9" step="0.01" value="0"></div>
    <small>Neck is attached to the pool boundary; pinch-off creates a freefall tear-drop. Volume is conserved.</small>
  </div>

<script>
(() => {
  // ===== Canvas/setup =====
  const cvs = document.getElementById('sim');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  let W=360, H=640;
  const pad = 20*DPR, rr = 20*DPR;

  const $out = document.getElementById('out');
  const $ten = document.getElementById('ten');
  const $vis = document.getElementById('vis');
  const $tilt= document.getElementById('tilt');

  function resize(){
    const b=cvs.getBoundingClientRect();
    W=Math.round(b.width*DPR); H=Math.round(b.height*DPR);
    cvs.width=W; cvs.height=H;
    world.init();
  }
  addEventListener('resize', resize);

  // ===== World =====
  const world = {
    box:null, shelf:null, outletX:0,
    NX: 140,               // horizontal cells
    dx: 1,                 // computed
    resH:[],  resFlux:[],  // reservoir height + flux
    poolH:[], poolFlux:[], // bottom pool height + flux
    resSum0: 0,            // initial area (sum of heights)
    outW(){ return parseFloat($out.value)*DPR; },

    neck:{ mass:0, len:0, rad:0 }, // attached ligament
    drops:[],

    init(){
      this.box = {x:pad, y:pad, w:W-2*pad, h:H-2*pad, r:rr};
      const sx = this.box.x+8*DPR, sy=this.box.y+this.box.h*0.16, sw=this.box.w-16*DPR, sh=8*DPR;
      this.shelf = {x:sx, y:sy, w:sw, h:sh};
      this.outletX = this.shelf.x + this.shelf.w/2;

      this.dx = this.shelf.w/this.NX;
      this.resH = new Array(this.NX).fill(this.shelf.y - (this.box.y+10*DPR));
      this.poolH= new Array(this.NX).fill(0);
      // meniscus hint at walls
      for(let i=0;i<6;i++){ this.resH[i]*=0.6; this.resH[this.NX-1-i]*=0.6; }
      this.resFlux = new Array(this.NX+1).fill(0);
      this.poolFlux= new Array(this.NX+1).fill(0);
      this.resSum0 = sum(this.resH);
      neckAreaMoved = 0;
      this.neck.mass=0; this.neck.len=0; this.neck.rad=0;
      this.drops.length=0;
    }
  };

  // ===== Helpers =====
  const DT = 1/60, G=900*DPR;
  function gvec(){
    const t=parseFloat($tilt.value);
    const gx=t, gy=1; const m=Math.hypot(gx,gy);
    return {ax:G*gx/m, ay:G*gy/m};
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function sum(arr){ let s=0; for(const v of arr) s+=v; return s; }

  // Conservative 1-D update (area-preserving)
  function sloshConservative(H, flux, bias, k){
    const N=H.length;
    for(let i=0;i<=N;i++){
      const Hl = (i===0? H[0] : H[i-1]);
      const Hr = (i===N? H[N-1] : H[i]);
      flux[i] = k * ( (Hl - Hr) + bias );
    }
    for(let i=0;i<N;i++){
      H[i] += (flux[i] - flux[i+1]);
      if (H[i] < 0) H[i] = 0;
    }
  }

  let neckAreaMoved = 0; // area removed from reservoir since init

  function step(){
    const visc = 0.05 + 1.2*parseFloat($vis.value);
    const tenMul = 0.6 + 1.5*parseFloat($ten.value);
    const {ax,ay} = gvec();
    const bias = ax * 0.32;

    // 1) slosh
    sloshConservative(world.resH, world.resFlux, bias, 0.18);
    sloshConservative(world.poolH, world.poolFlux, bias, 0.34);

    // Renormalize reservoir to keep exact area after clipping
    const targetRes = Math.max(0, world.resSum0 - neckAreaMoved);
    const curRes = sum(world.resH);
    if (curRes>0){
      const s = targetRes / curRes;
      for(let i=0;i<world.NX;i++) world.resH[i]*=s;
    }

    // 2) Outlet discharge (only from the outlet cell)
    const iOut = clamp(Math.floor((world.outletX - world.shelf.x)/world.dx),0,world.NX-1);
    const head = world.resH[iOut];
    if (head>0){
      const A = Math.max(2*DPR, world.outW());
      const c = 0.35;
      const flow = c * A * Math.sqrt(head) * DT; // area
      const dH = flow / world.dx;
      const removed = Math.min(world.resH[iOut], dH);
      world.resH[iOut] -= removed;
      neckAreaMoved += removed;
      world.neck.mass += removed * world.dx; // convert back to area
      world.neck.len = clamp(world.neck.len + 0.8*DT*DPR + Math.sqrt(head)*0.02, 2*DPR, 36*DPR);
      world.neck.rad = clamp(world.neck.rad + 0.7*DT*DPR, 2*DPR, 14*DPR);
    } else {
      world.neck.len = Math.max(0, world.neck.len - 14*DT);
      world.neck.rad = Math.max(1*DPR, world.neck.rad - 18*DT);
    }

    // 3) Pinch-off → free drop
    const detachThresh = (140*DPR*DPR) * tenMul;
    if (world.neck.mass > detachThresh){
      const r = Math.sqrt(world.neck.mass)*0.52;
      world.drops.push({
        x: world.outletX,
        y: world.shelf.y + world.shelf.h/2 + world.neck.len + r*0.1,
        vx: ax*DT*12,
        vy: 40*DPR,
        r
      });
      world.neck.mass = 0;
      world.neck.len  = world.neck.rad*0.35; // short residual ligament
    }

    // 4) Advance drops; on impact, distribute to pool (no bounce)
    const wallL = world.box.x+6*DPR, wallR=world.box.x+world.box.w-6*DPR;
    const floorY= world.box.y+world.box.h-6*DPR;

    for (const d of world.drops){
      d.vx += ax*DT; d.vy += ay*DT;
      d.vx *= (1 - visc*DT); d.vy *= (1 - visc*DT);
      d.x += d.vx*DT; d.y += d.vy*DT;
      if (d.x<wallL){ d.x=wallL; d.vx=0; }
      if (d.x>wallR){ d.x=wallR; d.vx=0; }

      if (d.y >= floorY){
        // Spread volume to neighbors (kernel 0.25,0.5,0.25)
        const i = clamp(Math.floor((d.x - world.shelf.x)/world.dx), 0, world.NX-1);
        const vol = d.r*d.r;               // area proxy
        const h = vol / world.dx;
        if (i>0) world.poolH[i-1] += h*0.25;
        world.poolH[i] += h*0.5;
        if (i<world.NX-1) world.poolH[i+1] += h*0.25;
        d.r = 0;
      }
    }
    for (let i=world.drops.length-1;i>=0;i--) if(world.drops[i].r<=0) world.drops.splice(i,1);
  }

  // ===== Drawing =====
  function rrRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }
  function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  function drawDevice(){
    const b=world.box;
    const g=ctx.createLinearGradient(0,b.y,0,b.y+b.h);
    g.addColorStop(0,'#d7443b'); g.addColorStop(1,'#a42e27');
    rrRect(ctx,b.x,b.y,b.w,b.h,b.r); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=6*DPR; ctx.strokeStyle='#7b1f1a'; ctx.stroke();
  }
  function drawShelf(){
    const s=world.shelf, rr=s.h/2, gap=world.outW(), gapX=world.outletX-gap/2;
    ctx.save(); ctx.fillStyle=css('--shelf');
    rrRect(ctx,s.x, s.y, gapX-s.x, s.h, rr); ctx.fill();
    rrRect(ctx,gapX+gap, s.y, s.x+s.w-(gapX+gap), s.h, rr); ctx.fill();
    ctx.restore();
  }

  // Draw the reservoir with the neck merged into the same path (shared boundary).
  function drawReservoir(){
    const s=world.shelf, x0=s.x, topY = y=> s.y - y;
    const iOut = clamp(Math.floor((world.outletX - s.x)/world.dx),0,world.NX-1);
    const rimX = x0 + iOut*world.dx;
    const rimY = topY(world.resH[iOut]);

    ctx.save();

    // Build a single closed path: left surface → neck (down & up) → right surface → base.
    ctx.beginPath();
    ctx.moveTo(x0, s.y);

    // left surface up to outlet rim
    for(let i=0;i<=iOut;i++){
      const x = x0 + i*world.dx;
      ctx.lineTo(x, topY(world.resH[i]));
    }

    // neck (attached) — two smooth curves meeting at a tip
    if (world.neck.len>1){
      const cx = world.outletX, cy = s.y + s.h/2;
      const L  = world.neck.len;
      const r  = Math.max(1*DPR, world.neck.rad);
      // left side down to tip
      ctx.quadraticCurveTo(cx - r*0.45, cy + L*0.35, cx, cy + L);
      // right side back up to rim
      ctx.quadraticCurveTo(cx + r*0.45, cy + L*0.35, rimX + r*0.55, rimY);
    }

    // continue right surface from just after the outlet
    for(let i=iOut+1;i<world.NX;i++){
      const x = x0 + i*world.dx;
      ctx.lineTo(x, topY(world.resH[i]));
    }

    // close along the shelf line
    ctx.lineTo(x0 + world.NX*world.dx, s.y);
    ctx.closePath();

    // Fill: light center; Outline: dark rim
    ctx.fillStyle=css('--oilCenter'); ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=css('--oilEdge'); ctx.stroke();

    ctx.restore();
  }

  function drawBottomPool(){
    const b=world.box, x0=world.shelf.x, base=b.y+b.h-6*DPR;
    let tot=0; for(const h of world.poolH) tot+=h; if(tot<=0) return;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x0, base);
    for(let i=0;i<world.NX;i++){
      const x = x0 + i*world.dx;
      ctx.lineTo(x, base - world.poolH[i]);
    }
    ctx.lineTo(x0 + world.NX*world.dx, base);
    ctx.closePath();

    const lg = ctx.createLinearGradient(x0,0,x0 + world.NX*world.dx,0);
    lg.addColorStop(0, css('--oilEdge'));
    lg.addColorStop(0.12, css('--oilCenter'));
    lg.addColorStop(0.88, css('--oilCenter'));
    lg.addColorStop(1, css('--oilEdge'));
    ctx.fillStyle=lg; ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=css('--oilEdge'); ctx.stroke();
    ctx.restore();
  }

  function drawDrops(){
    const center=css('--oilCenter'), edge=css('--oilEdge');
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=10*DPR;
    for(const d of world.drops){
      // Tear-drop oriented to velocity (never a perfect circle unless motion~0)
      const ang = Math.atan2(d.vy, d.vx);
      ctx.save();
      ctx.translate(d.x, d.y);
      ctx.rotate(ang);
      ctx.beginPath();
      ctx.moveTo(0, -d.r*1.05);
      ctx.quadraticCurveTo(d.r*0.9, -d.r*0.2, d.r*0.7, d.r*0.9);
      ctx.quadraticCurveTo(0, d.r*1.25, -d.r*0.7, d.r*0.9);
      ctx.quadraticCurveTo(-d.r*0.9, -d.r*0.2, 0, -d.r*1.05);
      const g = ctx.createRadialGradient(0,0,0, 0,0, d.r*1.2);
      g.addColorStop(0, center); g.addColorStop(1, edge);
      ctx.fillStyle=g; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  }

  // ===== Main loop =====
  resize();
  let last=performance.now();
  function frame(t){
    let acc=(t-last)/1000; last=t;
    while(acc>DT){ step(); acc-=DT; }
    ctx.clearRect(0,0,W,H);
    drawDevice();
    drawShelf();
    drawBottomPool();
    drawDrops();
    drawReservoir();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
