<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Fluid Fantasy — Wham-O Style (Portrait)</title>
<style>
  :root{
    --tank-red:#c52a28;
    --oil-blue:#1b84c6;
    --bezel:#ffffff;
  }
  html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  .wrap{
    display:flex;align-items:center;justify-content:center;height:100%;
    padding:10px;
  }
  .tank {
    position:relative; width:min(92vw, 520px); height:calc(100vh - 110px);
    max-height:860px; border-radius:26px; background:var(--tank-red);
    box-shadow:inset 0 0 0 12px var(--bezel), 0 8px 24px rgba(0,0,0,.45);
    overflow:hidden;
  }
  canvas{position:absolute; inset:0; width:100%; height:100%; display:block;}
  .instr{
    position:absolute; left:0; right:0; bottom:8px; text-align:center;
    font-size:14px; opacity:.8; text-shadow:0 1px 2px #000;
  }
  .btn{
    position:absolute; z-index:5; top:8px; padding:8px 12px;
    background:rgba(255,255,255,.15); border:1px solid rgba(255,255,255,.35);
    color:#fff; border-radius:12px; backdrop-filter: blur(6px);
    -webkit-tap-highlight-color: transparent;
  }
  .btn:hover{background:rgba(255,255,255,.22)}
  .btn.left{left:10px}
  .btn.right{right:10px}
  .btn.mid{left:50%; transform:translateX(-50%);}
</style>
</head>
<body>
<div class="wrap">
  <div class="tank" id="tank">
    <button class="btn left" id="fsBtn">Enter Fullscreen</button>
    <button class="btn mid" id="motionBtn">Enable Motion</button>
    <button class="btn right" id="resetBtn">Reset</button>
    <canvas id="c"></canvas>
    <div class="instr">Wham-O style • **Tilt** to flow • **Double-tap** to flip gravity</div>
  </div>
</div>

<script>
/* --------- basic setup --------- */
const tank = document.getElementById('tank');
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W=0,H=0, DPR = Math.max(1, window.devicePixelRatio||1);

function fit(){
  const r = tank.getBoundingClientRect();
  W = Math.floor(r.width * DPR); H = Math.floor(r.height * DPR);
  canvas.width = W; canvas.height = H;
}
fit(); addEventListener('resize', fit);

/* --------- world & parameters --------- */
const OIL_COLOR = '#1b84c6';
const TANK_BG   = '#c52a28';
const OUTLINE   = '#1a1a1a';

const N_PART = 120;           // total “drops”
const MASS    = 1;            // per particle mass (uniform)
const G_SCALE = 0.0006;       // gravity strength
const DAMP    = 0.985;        // velocity damping (viscosity feel)
const COHESION= 0.00025;      // how strongly droplets pull together
const REPULSE = 0.0007;       // short-range repulsion (prevents collapse)
const RADIUS  = 10 * DPR;     // visual radius of each particle
const FIELD_R = RADIUS*1.25;  // influence radius for blobby look
const WALL_PAD= 14 * DPR;

/* device gravity vector (updated by tilt or double-tap flip) */
let g = {x:0, y: G_SCALE}; // default: gently downward
let flipped = false;

/* white obstacle bars (x,y,w,h) in device pixels; we define in percents then scale */
function pct(x, y, w, h){
  return [x*W, y*H, w*W, h*H];
}
let obstacles = [];
function buildObstacles(){
  obstacles = [
    pct(0.06,0.12, 0.88, 0.015),
    pct(0.10,0.30, 0.40, 0.015),
    pct(0.58,0.38, 0.32, 0.015),
    pct(0.18,0.54, 0.64, 0.015),
    pct(0.10,0.77, 0.80, 0.015),
  ];
}
buildObstacles();
addEventListener('resize', buildObstacles);

/* --------- particle pool (fixed amount of oil) --------- */
const P = new Array(N_PART).fill(0).map(()=>({
  x: 0, y: 0, vx: 0, vy: 0
}));

function seedOil(){
  // start as a fat puddle near the top
  for(let i=0;i<N_PART;i++){
    const spread = 0.06; // % of tank
    P[i].x = (0.5 + (Math.random()-0.5)*spread) * W;
    P[i].y = (0.2 + (Math.random()-0.5)*spread) * H;
    P[i].vx = (Math.random()-0.5) * 0.3;
    P[i].vy = (Math.random()-0.5) * 0.3;
  }
}
seedOil();

/* --------- physics update --------- */
function update(dt){
  // pairwise forces: cohesion (longer range), repulsion (short)
  for(let i=0;i<N_PART;i++){
    let pi=P[i];
    // gravity & damping
    pi.vx = (pi.vx + g.x*dt) * DAMP;
    pi.vy = (pi.vy + g.y*dt) * DAMP;
  }
  for(let i=0;i<N_PART;i++){
    const pi = P[i];
    for(let j=i+1;j<N_PART;j++){
      const pj = P[j];
      let dx = pj.x - pi.x;
      let dy = pj.y - pi.y;
      let d2 = dx*dx + dy*dy;
      if (d2 === 0) continue;
      let d = Math.sqrt(d2);
      // normalized
      let ux = dx/d, uy = dy/d;

      // cohesion (pull together slightly)
      const fCoh = COHESION * Math.min(d, 120*DPR);
      pi.vx += fCoh*ux; pi.vy += fCoh*uy;
      pj.vx -= fCoh*ux; pj.vy -= fCoh*uy;

      // repulsion at close range (prevents total collapse)
      const minD = RADIUS*0.9;
      if(d < minD){
        const fRep = REPULSE*(1 - d/minD);
        pi.vx -= fRep*ux; pi.vy -= fRep*uy;
        pj.vx += fRep*ux; pj.vy += fRep*uy;
      }
    }
  }

  // integrate & collisions
  for(let i=0;i<N_PART;i++){
    let p=P[i];
    p.x += p.vx*dt*60;
    p.y += p.vy*dt*60;

    // walls (rounded-ish tank interior)
    if(p.x < WALL_PAD){ p.x = WALL_PAD; p.vx *= -0.25; }
    if(p.x > W-WALL_PAD){ p.x = W-WALL_PAD; p.vx *= -0.25; }
    if(p.y < WALL_PAD){ p.y = WALL_PAD; p.vy *= -0.25; }
    if(p.y > H-WALL_PAD){ p.y = H-WALL_PAD; p.vy *= -0.25; }

    // obstacles (AABB with friction)
    for(const ob of obstacles){
      const [ox,oy,ow,oh]=ob;
      if(p.x>ox && p.x<ox+ow && p.y>oy-8 && p.y<oy+oh+8){
        // resolve vertical first (feels like sliding on bars)
        if(p.y < oy+oh/2){ p.y = oy-1; p.vy *= -0.15; p.vx *= 0.92; }
        else { p.y = oy+oh+1; p.vy *= -0.15; p.vx *= 0.92; }
      }
    }
  }
}

/* --------- rendering --------- */
function drawBackground(){
  // red tank interior
  ctx.fillStyle = TANK_BG;
  ctx.fillRect(0,0,W,H);

  // white obstacle bars
  ctx.fillStyle = '#fff';
  for(const [x,y,w,h] of obstacles){
    // two-layer: subtle shadow + white bar
    ctx.fillRect(x, y+h*0.55, w, h*0.45);
    ctx.fillRect(x, y, w, h);
  }
}

// metaball-ish: draw blurred circles with additive blend, then colorize
function drawOil(){
  ctx.save();
  // layer to build “field”
  ctx.globalCompositeOperation='lighter';
  for(const p of P){
    const r = FIELD_R;
    const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
    grad.addColorStop(0, 'rgba(50,120,180,0.65)');
    grad.addColorStop(0.6, 'rgba(50,120,180,0.20)');
    grad.addColorStop(1, 'rgba(50,120,180,0)');
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
  }

  // slight outline “meniscus”
  ctx.globalCompositeOperation='source-over';
  ctx.lineWidth = 2*DPR;
  ctx.strokeStyle = 'rgba(10,10,10,0.35)';

  // coarse marching: sample grid & draw iso-contours by threshold approximation
  // (cheap trick: paint a semi-transparent blue coat; outline by compositing pass)
  ctx.globalAlpha=0.95;
  ctx.fillStyle = OIL_COLOR;
  // tint the accumulated field to uniform blue
  ctx.globalCompositeOperation='source-atop';
  ctx.fillRect(0,0,W,H);

  // soft outline
  ctx.globalCompositeOperation='source-over';
  ctx.strokeStyle='rgba(0,0,0,0.28)';
  ctx.lineWidth=1.5*DPR;
  // draw “suggested” outline by redrawing circles thinly (fast approximation)
  ctx.beginPath();
  for(const p of P){ ctx.moveTo(p.x+RADIUS,p.y); ctx.arc(p.x,p.y,RADIUS,0,Math.PI*2); }
  ctx.stroke();

  ctx.restore();
}

let last=performance.now();
function loop(t){
  const dt = Math.min(0.04, (t-last)/1000); last=t;
  update(dt);
  drawBackground();
  drawOil();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* --------- device orientation → gravity --------- */
function setGravityFromOrientation(e){
  // gamma: left/right tilt, beta: front/back
  const beta = (e.beta||0);   // -180..180
  const gamma = (e.gamma||0); // -90..90
  // map to canvas x/y (portrait)
  let gx =  Math.sin(gamma*Math.PI/180) * G_SCALE;
  let gy =  Math.sin(beta *Math.PI/180) * G_SCALE;
  if(flipped){ gx*=-1; gy*=-1; }
  g.x = gx; g.y = gy;
}

const motionBtn = document.getElementById('motionBtn');
motionBtn.addEventListener('click', async ()=>{
  // iOS requires a gesture to request permission
  try{
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function'){
      const r = await DeviceMotionEvent.requestPermission();
      if(r!=='granted') throw new Error('Motion permission not granted');
    }
  }catch(e){}
  addEventListener('deviceorientation', setGravityFromOrientation, true);
  motionBtn.style.display='none';
});

// Double-tap to flip gravity 180° (like turning the toy upside-down quickly)
let lastTap=0;
canvas.addEventListener('touchend', (e)=>{
  const now = performance.now();
  if(now-lastTap < 350){
    flipped = !flipped;
  }
  lastTap = now;
});

/* --------- UI: fullscreen & reset --------- */
document.getElementById('fsBtn').onclick = async ()=>{
  if(!document.fullscreenElement){ await tank.requestFullscreen?.(); }
  else { await document.exitFullscreen?.(); }
};
document.getElementById('resetBtn').onclick = ()=>{
  seedOil();
};

/* prevent scrolling bounce while interacting */
document.addEventListener('touchmove', e=>{ e.preventDefault(); }, {passive:false});
</script>
</body>
</html>
