<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fluid Fantasy – Oil Drip (no bounce)</title>
<style>
  :root {
    color-scheme: dark;
    --bg: #0b1420;
    --device: #c6352b;
    --device-dark: #a52a23;
    --bezel: #141d2a;
    --shelf: #eef1f6;
    --oil: #2c82ff;
    --oil-edge: #16488f;
  }
  html, body {
    margin:0; padding:0; background:var(--bg); font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display:flex; flex-direction:column; align-items:center; gap:14px;
  }
  .wrap { width:min(420px, 92vw); }
  .phone {
    position:relative;
    aspect-ratio: 9/16;
    background:linear-gradient(#1b2330, #0d1623);
    border-radius:28px; box-shadow: 0 14px 40px rgba(0,0,0,.55), inset 0 0 0 10px #0e1724;
    padding:18px;
  }
  canvas { width:100%; height:100%; display:block; border-radius:22px; background:transparent; }
  .panel {
    background:#0f1726; border:1px solid #1e2a42; border-radius:12px; padding:10px 12px; color:#cfd7e7;
  }
  .row { display:grid; grid-template-columns: 1fr auto; align-items:center; gap:10px; margin:6px 0; }
  input[type="range"] { width: 52vw; max-width: 440px; }
  small { color:#a7b1c8; }
  .bullets { color:#cfd7e7; font-size:13px }
  .bullets b{color:#fff}
</style>
</head>
<body>
  <div class="wrap phone">
    <canvas id="sim"></canvas>
  </div>

  <div class="wrap panel">
    <div class="row">
      <label>Tension (stickiness)</label>
      <input id="tension" type="range" min="0" max="1" step="0.01" value="0.55">
    </div>
    <div class="row">
      <label>Viscosity (drag)</label>
      <input id="visc" type="range" min="0" max="1" step="0.01" value="0.35">
    </div>
    <div class="row">
      <label>Sim Tilt (◀︎ / ▶︎)</label>
      <input id="tilt" type="range" min="-0.8" max="0.8" step="0.01" value="0">
    </div>
    <small>Tip: Tilt left/right to slosh. All top oil starts moving down immediately; shelves split it into tear-drops. No bounce.</small>
  </div>

  <div class="wrap bullets">
    <ul>
      <li>Drops hang, grow, detach, and fall with <b>no bounce</b>.</li>
      <li><b>Tension↑</b> = holds longer before detaching. <b>Viscosity↑</b> = slower fall/slide.</li>
      <li>The <b>top pool drains immediately</b>; volume is conserved in a <b>bottom pool</b>.</li>
      <li>Use <b>Sim Tilt</b> to slosh left/right. (Device tilt can be wired later.)</li>
    </ul>
  </div>

<script>
(() => {
  // ---------- Canvas & world units ----------
  const cvs = document.getElementById('sim');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=360, H=640; // logical
  function resize() {
    const r = cvs.getBoundingClientRect();
    W = Math.round(r.width * DPR);
    H = Math.round(r.height * DPR);
    cvs.width = W; cvs.height = H;
  }
  resize(); addEventListener('resize', resize);

  // ---------- Container & shelves ----------
  const pad = 20 * DPR;
  const borderR = 20 * DPR;
  const well = { x: pad, y: pad, w: W - pad*2, h: H - pad*2, r: borderR };

  // shelves: line segments inside the well
  const shelves = [
    {x1: .18, y:.22, len:.24}, {x1:.58, y:.22, len:.24},
    {x1: .12, y:.32, len:.12}, {x1:.36, y:.34, len:.32},
    {x1: .12, y:.44, len:.52}, {x1:.76, y:.44, len:.12},
    {x1: .15, y:.56, len:.14}, {x1:.40, y:.58, len:.48},
    {x1: .12, y:.70, len:.66}, {x1:.86, y:.71, len:.06},
  ].map(s => ({
    x: () => well.x + s.x1*well.w,
    y: () => well.y + s.y*well.h,
    w: () => s.len*well.w,
    h: () => 6*DPR
  }));

  // ---------- Controls ----------
  const $tension = document.getElementById('tension');
  const $visc = document.getElementById('visc');
  const $tilt = document.getElementById('tilt');

  // ---------- Fluid state ----------
  const PX = DPR; // particle radius (base)
  const N_INIT = 700;      // initial "top pool" particles
  const particles = [];    // free/falling particles
  const stuckSites = [];   // drip sites along shelves
  let bottomPool = 0;      // "volume" accumulated at bottom

  // Populate initial top pool (a contiguous slab that immediately moves down)
  function seedTopPool() {
    particles.length = 0;
    bottomPool = 0;
    const poolH = 38*DPR;
    const margin = 10*DPR;
    for (let i=0;i<N_INIT;i++){
      // blue oil band across the top, slight sine contour
      const fx = (i % 100) / 100;
      const x = well.x + margin + fx*(well.w-2*margin);
      const row = Math.floor(i/100);
      const yBase = well.y + 8*DPR + Math.sin(fx*Math.PI*2)*6*DPR;
      const y = yBase + (row%4)*(poolH/4);
      particles.push(makeParticle(x, y, 0, 0, PX));
    }
  }

  function makeParticle(x,y,vx,vy,r){
    return {x,y,vx,vy,r, free:true}; // free=true => not attached to a site
  }

  // Create fixed drip sites along every shelf to collect oil until detaching.
  function buildDripSites(){
    stuckSites.length = 0;
    shelves.forEach(sh=>{
      const count = Math.max(2, Math.floor(sh.w()/60));
      for (let i=0;i<count;i++){
        const px = sh.x() + (i+0.5)*sh.w()/count;
        const py = sh.y() - 2*DPR; // slightly above
        stuckSites.push({x:px, y:py, mass:0, vx:0, vy:0});
      }
    });
  }

  seedTopPool();
  buildDripSites();

  // ---------- Physics ----------
  const DT = 1/60;             // fixed timestep
  const G = 900 * DPR;         // base gravity magnitude (px/s^2)

  function gravityVec(){
    // Down is +y. Tilt slider sloshes left/right.
    const tilt = parseFloat($tilt.value); // -0.8..0.8
    // Build vector then normalize to keep |g| constant.
    const gx = tilt;
    const gy = 1; // always down
    const mag = Math.hypot(gx,gy);
    return { ax: (G*gx)/mag, ay: (G*gy)/mag };
  }

  function step() {
    const visc = 0.05 + 1.2*parseFloat($visc.value); // 0.05..1.25 (heavier drag)
    const {ax, ay} = gravityVec();
    const wallL = well.x + 6*DPR, wallR = well.x + well.w - 6*DPR;
    const floorY = well.y + well.h - 6*DPR;

    // 1) Move free particles under gravity
    for (let p of particles) {
      if (!p.free) continue;
      p.vx += ax*DT;
      p.vy += ay*DT;

      // viscous drag (simple)
      p.vx *= (1 - visc*DT);
      p.vy *= (1 - visc*DT);

      // integrate
      p.x += p.vx*DT;
      p.y += p.vy*DT;

      // walls: clamp, no bounce
      if (p.x < wallL){ p.x = wallL; p.vx = 0; }
      if (p.x > wallR){ p.x = wallR; p.vx = 0; }

      // shelves collision: if crossing a shelf plane from above -> stick to a site
      for (let sh of shelves){
        const yTop = sh.y() - p.r; // top edge to catch from above
        if (p.y >= yTop && p.y <= yTop + sh.h() && p.x >= sh.x() && p.x <= sh.x()+sh.w()){
          // slide along shelf with heavy friction until we hit nearest site
          // no bounce: zero vy, keep only gentle vx from tilt
          p.y = yTop; p.vy = 0;
          p.vx *= 0.3;
          // snap to nearest drip site on this shelf when slow enough
          const site = nearestSiteOnShelf(p.x, sh);
          if (Math.abs(p.vx) < 10*DPR) {
            p.free = false; // attach to site (contributes mass)
            site.mass += p.r*p.r; // proxy for volume
          }
          break;
        }
      }

      // bottom pool collection
      if (p.y >= floorY){
        bottomPool += p.r*p.r;
        // recycle particle back to top very small (volume conservation visually)
        p.x = well.x + (Math.random()*well.w*0.8 + 0.1*well.w);
        p.y = well.y + 8*DPR;
        p.vx = 0; p.vy = 0;
      }
    }

    // 2) Drip site behavior (surface tension & detachment)
    const baseThresh = 120*DPR*DPR; // mass threshold proxy
    const tMul = 0.3 + 1.6*parseFloat($tension.value); // 0.3..1.9
    for (let s of stuckSites){
      if (s.mass <= 0) continue;
      // The attached blob hangs; add gravity to make a teardrop bulge & sway slightly
      s.vx += ax*DT*0.02; s.vy += ay*DT*0.02;
      s.vx *= 0.95; s.vy *= 0.95;

      // Detach when mass exceeds threshold adjusted by tension
      if (s.mass > baseThresh * tMul){
        // convert blob into a falling particle (tear drop a bit larger)
        const r = Math.sqrt(s.mass) * 0.6;
        particles.push(makeParticle(s.x, s.y + 3*DPR, s.vx*20, Math.max(40*DPR, s.vy*20), r));
        s.mass = 0; s.vx = s.vy = 0;
      } else {
        // also ooze along shelf slowly due to tilt (but still attached)
        s.x = clamp(s.x + ax*DT*0.02, well.x+10*DPR, well.x+well.w-10*DPR);
      }
    }
  }

  function nearestSiteOnShelf(x, sh){
    let best=null, d=1e9;
    for (let s of stuckSites){
      // filter to sites that sit on this shelf (same y within 1px)
      if (Math.abs(s.y - (sh.y()-2*DPR)) < 1.5*DPR){
        const dd = Math.abs(s.x - x);
        if (dd < d){ d=dd; best=s; }
      }
    }
    return best || stuckSites[0];
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // ---------- Rendering ----------
  function drawPhoneWell(){
    // red device body
    ctx.save();
    const {x,y,w,h,r} = well;
    // inner red chassis
    const grd = ctx.createLinearGradient(0,y,0,y+h);
    grd.addColorStop(0, '#d7443b'); grd.addColorStop(1, '#a42e27');
    roundedRect(ctx, x, y, w, h, r); ctx.fillStyle = grd; ctx.fill();
    ctx.lineWidth = 6*DPR; ctx.strokeStyle = '#7b1f1a'; ctx.stroke();
    ctx.restore();
  }

  function drawShelves(){
    ctx.save();
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--shelf');
    shelves.forEach(sh=>{
      const x = sh.x(), y = sh.y(), w = sh.w(), h = sh.h();
      const rr = h/2;
      roundedRect(ctx, x, y, w, h, rr);
      ctx.shadowColor = 'rgba(0,0,0,.25)'; ctx.shadowBlur = 6*DPR;
      ctx.fill();
    });
    ctx.restore();
  }

  function drawTopSurface(){
    // purely decorative rippled band that shrinks as particles leave (optional)
    // To keep visuals simple with "immediate drain", we keep a thin strip
    const band = 18*DPR;
    const x = well.x+6*DPR, y = well.y+6*DPR, w = well.w-12*DPR, h = band;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x, y+h*0.2);
    const lobes = 4;
    for (let i=0;i<lobes;i++){
      const sx = x + (i+0.5)*w/lobes;
      ctx.quadraticCurveTo(sx, y+h*0.8, x + (i+1)*w/lobes, y+h*0.2);
    }
    ctx.lineTo(x+w, y+h);
    ctx.lineTo(x, y+h);
    ctx.closePath();
    const oil = getComputedStyle(document.documentElement).getPropertyValue('--oil');
    const edge = getComputedStyle(document.documentElement).getPropertyValue('--oil-edge');
    const grad = ctx.createLinearGradient(0,y,0,y+h);
    grad.addColorStop(0, edge.trim()); grad.addColorStop(1, oil.trim());
    ctx.fillStyle = grad; ctx.fill();
    ctx.restore();
  }

  function drawParticles(){
    const oil = getComputedStyle(document.documentElement).getPropertyValue('--oil').trim();
    const edge = getComputedStyle(document.documentElement).getPropertyValue('--oil-edge').trim();
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,.25)'; ctx.shadowBlur = 10*DPR;
    for (let p of particles){
      // draw as tear-ish (slight squash if fast)
      const sp = Math.hypot(p.vx, p.vy);
      const k = clamp(sp / (400*DPR), 0, 0.35);
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, p.r*(1+k), p.r*(1-k), Math.atan2(p.vy,p.vx), 0, Math.PI*2);
      ctx.fillStyle = oil; ctx.fill();
      ctx.lineWidth = 2*DPR; ctx.strokeStyle = edge; ctx.stroke();
    }
    ctx.restore();
  }

  function drawDripSites(){
    const oil = getComputedStyle(document.documentElement).getPropertyValue('--oil').trim();
    const edge = getComputedStyle(document.documentElement).getPropertyValue('--oil-edge').trim();
    ctx.save();
    for (let s of stuckSites){
      if (s.mass <= 0) continue;
      const r = Math.sqrt(s.mass) * 0.35;
      ctx.beginPath();
      // tear drop hanging from site:
      ctx.ellipse(s.x, s.y + r*0.6, r*0.9, r*1.1, 0, 0, Math.PI*2);
      ctx.fillStyle = oil; ctx.fill();
      ctx.lineWidth = 2*DPR; ctx.strokeStyle = edge; ctx.stroke();

      // tiny neck to shelf
      ctx.beginPath();
      ctx.moveTo(s.x-2*DPR, s.y);
      ctx.lineTo(s.x+2*DPR, s.y);
      ctx.strokeStyle = oil; ctx.lineWidth = 3*DPR; ctx.stroke();
    }
    ctx.restore();
  }

  function drawBottomPool(){
    if (bottomPool<=0) return;
    const oil = getComputedStyle(document.documentElement).getPropertyValue('--oil').trim();
    const edge = getComputedStyle(document.documentElement).getPropertyValue('--oil-edge').trim();
    const area = bottomPool * 0.004; // visual scale
    const level = clamp(area / well.w, 0, well.h*0.3);
    const x = well.x+6*DPR;
    const y = well.y + well.h - level - 6*DPR;
    const w = well.w - 12*DPR;
    const h = level;

    ctx.save();
    roundedRect(ctx, x, y, w, h, 10*DPR);
    ctx.fillStyle = oil; ctx.fill();
    ctx.lineWidth = 3*DPR; ctx.strokeStyle = edge; ctx.stroke();
    ctx.restore();
  }

  function roundedRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  // ---------- Main loop ----------
  let last = performance.now();
  function loop(t){
    // fixed-step update
    let acc = (t-last)/1000;
    last = t;
    while (acc > DT){ step(); acc -= DT; }

    // draw
    ctx.clearRect(0,0,W,H);
    drawPhoneWell();
    drawShelves();
    drawTopSurface();
    drawBottomPool();
    drawDripSites();
    drawParticles();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ---------- Reset when resizing or tweaking layout ----------
  window.addEventListener('resize', ()=>{
    seedTopPool(); buildDripSites();
  });

})();
</script>
</body>
</html>
