<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Fluid Fantasy – Visual Baseline</title>
<style>
  :root {
    --bg:#0f1a28;
    --panel:#152338;
    --text:#e9f0ff;
    --accent:#5aa2ff;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
  }
  .wrap{
    max-width: 520px;
    margin: 18px auto 28px;
    padding: 16px;
  }
  .bar{
    display:flex;align-items:center;gap:.8rem;
    background:var(--panel);
    padding:12px 14px;border-radius:12px;
    box-shadow: 0 4px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
  }
  .title{ font-weight:700; font-size:1.15rem; letter-spacing:.2px; }
  .hint{opacity:.75;font-size:.9rem;margin-top:10px}
  canvas{ display:block; width:100%; height:auto; }
  .stage{
    margin-top:14px;
    background:linear-gradient(180deg,#0c1624,#0a1420);
    padding:16px;border-radius:18px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 10px 28px rgba(0,0,0,.35);
  }
  .chip{
    margin-left:auto; padding:6px 10px; border-radius:999px;
    background:#0b1b2e; color:#a6c4ff; font-size:.85rem
  }
  .small{ font-size:.85rem; opacity:.9 }
</style>
</head>
<body>
  <div class="wrap">
    <div class="bar">
      <div class="title">Fluid Fantasy</div>
      <div class="chip">Visual Baseline</div>
    </div>

    <div class="stage">
      <!-- Fixed-logical size canvas; JS will handle HiDPI scaling -->
      <canvas id="tank" width="360" height="640" aria-label="Fluid tank canvas"></canvas>
    </div>

    <p class="hint">
      You should immediately see: red rounded container, light shelf lines, and a blue oil pool at the top with a dark rim.
      This file has **no physics/tilt** yet—just visuals to validate draw order.
    </p>
  </div>

<script>
(function(){
  const canvas = document.getElementById('tank');
  const ctx = canvas.getContext('2d', { alpha: false });

  // --- HiDPI / devicePixelRatio scaling for crisp lines on iPhone ---
  function fitHiDPI() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.round(rect.width  * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fitHiDPI();
  window.addEventListener('resize', () => { fitHiDPI(); draw(); });

  // --- Geometry for the red rounded container (the "tank") ---
  const tank = {
    x: 12, y: 12,
    w: () => canvas.getBoundingClientRect().width - 24,
    h: () => canvas.getBoundingClientRect().height - 24,
    r: 22
  };

  function roundedRectPath(x,y,w,h,r){
    const p = new Path2D();
    const rr = Math.min(r, w/2, h/2);
    p.moveTo(x+rr, y);
    p.arcTo(x+w, y,   x+w, y+h, rr);
    p.arcTo(x+w, y+h, x,   y+h, rr);
    p.arcTo(x,   y+h, x,   y,   rr);
    p.arcTo(x,   y,   x+w, y,   rr);
    p.closePath();
    return p;
  }

  // --- Shelf layout (visible + used for collisions later) ---
  function getShelves() {
    const W = tank.w(), H = tank.h();
    // choose Y positions as percentages; gaps create "holes"
    return [
      { y: H*0.22, gaps: [[W*0.40,W*0.62]] },
      { y: H*0.36, gaps: [[W*0.15,W*0.35],[W*0.75,W*0.95]] },
      { y: H*0.50, gaps: [[W*0.55,W*0.82]] },
      { y: H*0.64, gaps: [[W*0.10,W*0.28],[W*0.45,W*0.60]] },
      { y: H*0.78, gaps: [[W*0.70,W*0.92]] },
    ];
  }

  function drawShelves() {
    const W = tank.w(), H = tank.h();
    const shelves = getShelves();
    const x0 = tank.x + 14, x1 = tank.x + W - 14;

    ctx.save();
    ctx.lineWidth = 6;                   // shelf thickness
    ctx.lineCap = 'round';
    ctx.strokeStyle = 'rgba(230,238,255,0.9)';
    ctx.shadowColor = 'rgba(0,0,0,0.18)';
    ctx.shadowBlur = 2;
    shelves.forEach(s => {
      let start = x0;
      s.gaps.forEach(([gx0, gx1]) => {
        // draw left segment up to the gap
        segment(start, tank.y + s.y, tank.x + gx0, tank.y + s.y);
        start = tank.x + gx1;
      });
      // right tail after last gap
      segment(start, tank.y + s.y, x1, tank.y + s.y);
    });
    ctx.restore();

    function segment(xa,ya,xb,yb){
      if (xb - xa <= 8) return; // skip tiny segments
      ctx.beginPath();
      ctx.moveTo(xa,ya);
      ctx.lineTo(xb,yb);
      ctx.stroke();
    }
  }

  // --- Blue oil pool (static for now; wavy bottom, visible stroke) ---
  function drawTopOilPool() {
    const W = tank.w(), H = tank.h();
    const x = tank.x + 10, y = tank.y + 10;
    const w = W - 20, h = Math.max(70, H*0.12); // pool height
    const wave = Math.min(26, H*0.05);          // waviness amplitude

    ctx.save();
    // clip to the inside of the tank so oil follows shape
    ctx.clip( roundedRectPath(tank.x, tank.y, W, H, tank.r) );

    // shadow under oil for depth
    ctx.shadowColor = 'rgba(0,0,0,0.28)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 2;

    // oil fill
    const p = new Path2D();
    p.moveTo(x, y);
    p.lineTo(x+w, y);
    p.lineTo(x+w, y+h - wave);
    // wavy bottom edge
    const segments = 5;
    const segW = w / segments;
    for (let i=0;i<segments;i++){
      const cx = x + w - segW*i - segW/2;
      const cy = y + h - (i%2 ? wave*0.35 : wave);
      const nx = x + w - segW*(i+1);
      p.quadraticCurveTo(cx, cy, nx, y+h - wave*(i%2?1:0.35));
    }
    p.lineTo(x, y+h - wave);
    p.closePath();

    // fill + rim
    ctx.fillStyle = '#2e80ff';
    ctx.fill(p);
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#0b2e66'; // thin dark rim so it’s clearly visible
    ctx.stroke(p);

    ctx.restore();
  }

  function drawTank() {
    const W = tank.w(), H = tank.h();

    // outer background clear
    ctx.save();
    ctx.fillStyle = '#0c1624';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();

    // red rounded tank body (with inner bevel)
    const path = roundedRectPath(tank.x, tank.y, W, H, tank.r);

    // base
    ctx.save();
    ctx.fillStyle = '#cf2e2e';
    ctx.fill(path);

    // inner gloss/edge
    ctx.clip(path);
    // inner border
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 8;
    ctx.stroke(path);
    // inner highlight
    const grad = ctx.createLinearGradient(0, tank.y, 0, tank.y+H);
    grad.addColorStop(0, 'rgba(255,255,255,0.20)');
    grad.addColorStop(0.08, 'rgba(255,255,255,0.12)');
    grad.addColorStop(0.92, 'rgba(0,0,0,0.08)');
    grad.addColorStop(1, 'rgba(0,0,0,0.18)');
    ctx.fillStyle = grad;
    ctx.fill(path);
    ctx.restore();
  }

  function draw() {
    drawTank();       // 1) red container first
    drawShelves();    // 2) shelves second (clearly visible)
    drawTopOilPool(); // 3) blue oil on top (with rim)
    drawDebugLabel();
  }

  function drawDebugLabel(){
    const W = tank.w();
    ctx.save();
    ctx.font = '12px ui-sans-serif, system-ui';
    ctx.fillStyle = 'rgba(233,240,255,0.9)';
    ctx.textAlign = 'right';
    ctx.fillText('Baseline: background → shelves → oil', tank.x + W - 10, tank.y + 22);
    ctx.restore();
  }

  // initial paint
  draw();

  // optional: expose a simple redraw for quick testing in console
  window._redrawFluidBaseline = draw;
})();
</script>
</body>
</html>
