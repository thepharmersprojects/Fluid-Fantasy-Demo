<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Fluid Fantasy — Slosh + Drip Demo</title>
<style>
  :root{
    --inset-top: env(safe-area-inset-top);
    --inset-bottom: env(safe-area-inset-bottom);
    --inset-left: env(safe-area-inset-left);
    --inset-right: env(safe-area-inset-right);
  }
  html,body{margin:0;height:100%;background:#0b1220;color:#cfe7ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  body{min-height:100dvh;display:flex;flex-direction:column}
  header,footer{
    position:relative;z-index:1000;display:flex;gap:10px;align-items:center;flex-wrap:wrap;
    padding:12px calc(12px + var(--inset-right)) 12px calc(12px + var(--inset-left));
    background:#0e162a
  }
  button,input[type=range]{appearance:none;border:none;border-radius:8px;padding:8px 12px;background:#243557;color:#cfe7ff;font-weight:700;touch-action:manipulation;cursor:pointer}
  input[type=range]{width:140px}
  label{display:flex;align-items:center;gap:6px;font-size:12px;opacity:.95}
  #hud{opacity:.9}
  #diag{position:relative;z-index:1000;padding:10px calc(14px + var(--inset-right)) 10px calc(14px + var(--inset-left));
        background:#0e162a;border-top:1px solid #1e2b4a}
  #card{background:#132245;border-radius:14px;padding:12px 14px;max-width:520px}
  code{background:#0d1933;padding:2px 6px;border-radius:6px}
  #stage{position:relative;flex:1;min-height:0}
  .back{position:absolute;inset:20px;border-radius:22px;background:#c42529;box-shadow:0 0 0 1px rgba(0,0,0,.28) inset;pointer-events:none}
  canvas{position:absolute;inset:20px;border-radius:22px;display:block;width:calc(100% - 40px);height:calc(100% - 40px)}
  .frontTint{position:absolute;inset:20px;border-radius:22px;pointer-events:none;background:linear-gradient(#e33,rgba(220,30,30,.25)) ;mix-blend-mode:multiply;opacity:.18}
  .frame{position:absolute;inset:0;pointer-events:none;border-radius:28px;border:12px solid rgba(255,255,255,.14);
         box-shadow:0 0 0 2px rgba(255,255,255,.10) inset,0 0 0 1px rgba(0,0,0,.55),0 18px 40px rgba(0,0,0,.45)}
  footer{border-top:1px solid #1e2b4a;padding-bottom:calc(12px + var(--inset-bottom))}
</style>
</head>
<body>
<header>
  <strong>Fluid Fantasy</strong>
  <button id="btnMotion">Enable Motion</button>
  <button id="btnLock">Lock Orientation</button>
  <label>Viscosity <input id="visc" type="range" min="0" max="100" value="70"></label>
  <label>Surface Tension <input id="tens" type="range" min="0" max="100" value="70"></label>
  <label>Drip Tilt° <input id="tilt" type="range" min="4" max="30" value="14"></label>
  <span id="hud">Ready</span>
</header>

<div id="diag">
  <div id="card">
    <div>Secure origin (https): <code id="secure">no</code></div>
    <div>Motion events flowing: <code id="motion">no</code></div>
    <div>Gravity (x,y): <code id="g">0.00, 1.00</code></div>
  </div>
</div>

<div id="stage">
  <div class="back"></div>
  <canvas id="c"></canvas>
  <div class="frontTint"></div>
  <div class="frame"></div>
</div>

<footer>
  <span>Tip gently: blue oil **sloshes** to match the container, then **drips** off the top shelf as a teardrop and merges at the bottom. Mass is conserved.</span>
</footer>

<script>
(()=>{
// ------------------ motion / diagnostics ------------------
const secure = (location.protocol==='https:'||location.hostname==='localhost'||location.hostname==='127.0.0.1');
document.getElementById('secure').textContent = secure ? 'yes' : 'no';
let motionFlow=false, gravity={x:0,y:1};
function updDiag(){
  document.getElementById('motion').textContent = motionFlow?'yes':'no';
  document.getElementById('g').textContent = `${gravity.x.toFixed(2)}, ${gravity.y.toFixed(2)}`;
}
async function enableMotion(){
  try{
    if (window.DeviceMotionEvent && DeviceMotionEvent.requestPermission) { try{ await DeviceMotionEvent.requestPermission(); }catch{} }
    if (window.DeviceOrientationEvent && DeviceOrientationEvent.requestPermission) { try{ await DeviceOrientationEvent.requestPermission(); }catch{} }
  }catch{}
  addEventListener('deviceorientation', e => { gravity.x=(e.gamma||0)/45; gravity.y=(e.beta||0)/45; motionFlow=true; }, {passive:true});
  addEventListener('devicemotion', e => { const a=e.accelerationIncludingGravity||{}; gravity.x=(a.x||0)/9.81; gravity.y=(a.y||0)/9.81; motionFlow=true; }, {passive:true});
  const b=document.getElementById('btnMotion'); b.textContent='Motion Enabled'; b.disabled=true;
}
document.getElementById('btnMotion').addEventListener('click', enableMotion);

// iOS orientation: show tip (programmatic lock is limited)
document.getElementById('btnLock').addEventListener('click',()=>{
  alert('For a true lock on iPhone, use Control Center → Rotation Lock. The page will still adapt to tilt.');
});

// ------------------ UI ------------------
const hud=document.getElementById('hud');
let VISC=0.7, TENS=0.7, DRIP_ON=14, DRIP_OFF=9;
const viscEl=document.getElementById('visc'), tensEl=document.getElementById('tens'), tiltEl=document.getElementById('tilt');
viscEl.oninput=()=>VISC=+viscEl.value/100;
tensEl.oninput=()=>TENS=+tensEl.value/100;
tiltEl.oninput=()=>{DRIP_ON=+tiltEl.value; DRIP_OFF=Math.max(4,Math.round(DRIP_ON*0.65));};

// ------------------ canvas & geometry ------------------
const canvas=document.getElementById('c'), ctx=canvas.getContext('2d');
let W=0,H=0,dpr=1;
function resize(){
  dpr=Math.max(1,Math.min(2,devicePixelRatio||1));
  const r=canvas.getBoundingClientRect(); W=r.width; H=r.height;
  canvas.width=Math.floor(W*dpr); canvas.height=Math.floor(H*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  layout();
}
addEventListener('resize', resize, {passive:true}); resize();

// shelves/pegs areas
const rects=[], pegs=[];
let topShelf, midShelf, bottomShelf, cavity;
function addRect(px,py,pw,ph){ rects.push({x:20+(W-40)*px, y:20+(H-40)*py, w:(W-40)*pw, h:(H-40)*ph}); }
function addPeg(px,py,r){ pegs.push({x:20+(W-40)*px, y:20+(H-40)*py, r}); }

function layout(){
  rects.length=0; pegs.length=0;
  cavity = {x:20,y:20,w:W-40,h:H-40,r:22};
  addRect(0.08,0.14,0.84,0.018); topShelf=rects[rects.length-1];
  addRect(0.30,0.45,0.20,0.018);  midShelf=rects[rects.length-1];
  addRect(0.14,0.86,0.72,0.025);  bottomShelf=rects[rects.length-1];
  addPeg(0.62,0.30,12); addPeg(0.70,0.54,10); addPeg(0.48,0.60,8);
}

// ------------------ oil model ------------------
const BLUE='#2a8cff', EDGE='rgba(0,0,0,.95)';
const MASS_TOTAL=950;
let massTop=MASS_TOTAL, massDrops=0, massBottom=0;

// slosh state (first-order spring toward gravity plane)
let sloshTop={ox:0, oy:-12, vel:0}, sloshBot={ox:0, oy:12, vel:0};

function gUnit(){ const m=Math.hypot(gravity.x,gravity.y)||1; return {gx:gravity.x/m, gy:gravity.y/m}; }
function tiltDegX(){ const {gx}=gUnit(); return Math.asin(Math.min(1,Math.max(-1,Math.abs(gx))))*180/Math.PI; }

const drops=[]; let meniscusPinned=true, dripPhase=0, dropAcc=0;
function emitDrop(dt){
  if (massTop<=0) return;
  const td=tiltDegX();
  if (meniscusPinned && td>=DRIP_ON) meniscusPinned=false;
  else if (!meniscusPinned && td<=DRIP_OFF) meniscusPinned=true;
  dripPhase = meniscusPinned ? Math.max(0,dripPhase-dt*2) : Math.min(1,dripPhase+dt*2);
  if (meniscusPinned||dripPhase<=0) return;

  const {gx,gy}=gUnit(); const down=Math.max(0, gy + Math.abs(gx)*.15);
  dropAcc += (0.25+0.75*down)*dripPhase*(1-TENS*0.5)*dt*120;

  if (dropAcc>=1 && massTop>0){
    dropAcc-=1;
    const m = Math.min(massTop, 6 + 10*TENS);
    massTop -= m; massDrops += m;
    // spawn at the downhill edge of the top shelf
    const right = gx>=0;
    const x = right ? (topShelf.x + topShelf.w - 10) : (topShelf.x + 10);
    const y = topShelf.y + topShelf.h/2;
    drops.push({x,y,vx:gx*0.25,vy:gy*0.25,m,rx:6,ry:9});
  }
}

const GRAVITY_SCALE=0.12, PLATE_DRAG=6.0;
function collidePeg(d,pg){
  const dx=d.x-pg.x, dy=d.y-pg.y, dist=Math.hypot(dx,dy), minR=pg.r+Math.max(d.rx,d.ry)*0.85;
  if (dist<minR){
    const nx=(dx||.001)/(dist||1), ny=(dy||.001)/(dist||1), push=(minR-dist);
    d.x+=nx*push; d.y+=ny*push;
    const {gx,gy}=gUnit(); const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
  }
}
function collideRect(d,rc){
  const L=rc.x,R=L+rc.w,T=rc.y,B=T+rc.h,r=Math.max(d.rx,d.ry)*0.85;
  if (d.x>L-r&&d.x<R+r&&d.y>T-r&&d.y<B+r){
    const dl=Math.abs(d.x-L),dr=Math.abs(R-d.x),dt=Math.abs(d.y-T),db=Math.abs(B-d.y);
    const m=Math.min(dl,dr,dt,db);
    if (m===dt){ d.y=T-r; d.ry*=.88; d.rx*=1.06; }
    else if (m===db){ d.y=B+r; }
    else if (m===dl){ d.x=L-r; } else { d.x=R+r; }
    const {gx,gy}=gUnit(); const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
  }
}

function stepDrops(dt){
  emitDrop(dt);
  const {gx,gy}=gUnit();
  for (let i=drops.length-1;i>=0;i--){
    const d=drops[i];
    d.vx=(d.vx+gx*GRAVITY_SCALE)*Math.exp(-(VISC*0.9+PLATE_DRAG)*dt);
    d.vy=(d.vy+gy*GRAVITY_SCALE)*Math.exp(-(VISC*0.9+PLATE_DRAG)*dt);
    const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
    d.x+=d.vx*dt*60; d.y+=d.vy*dt*60;
    // walls
    const pad=Math.max(d.rx,d.ry)*.85, L=20+pad, R=W+20-pad, T=20+pad, B=H+20-pad;
    if (d.x<L) d.x=L; if (d.x>R) d.x=R; if (d.y<T) d.y=T; if (d.y>B) d.y=B;
    // obstacles
    for (const rc of rects){ collideRect(d,rc); }
    for (const pg of pegs){ collidePeg(d,pg); }
    // absorption
    const bottomY=bottomShelf.y-4;
    if (d.y>bottomY-d.ry*.5){
      const ab=Math.min(d.m, d.m*(0.25+0.65*TENS)*0.5);
      d.m-=ab; massDrops-=ab; massBottom+=ab;
      if (d.m<=.6){ drops.splice(i,1); continue; }
    }
    // teardrop shaping
    const sp=Math.hypot(d.vx,d.vy), A=d.m;
    let elong=Math.max(1.2,1.15+0.6*Math.tanh(sp*0.7)), rx=Math.sqrt(A/(Math.PI*elong)), ry=rx*elong;
    if (ry>10){ ry=10; rx=A/(Math.PI*ry); }
    d.rx=rx; d.ry=ry;
  }
  // conserve mass
  const total = massTop + massDrops + massBottom, drift = MASS_TOTAL-total;
  if (Math.abs(drift)>1e-6){ if (massTop>=massBottom) massTop+=drift; else massBottom+=drift; }
}

// ------------------ slosh rendering helpers ------------------
function roundRectPath(ctx,x,y,w,h,r){
  const rr=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}

// Fill a rounded-rect basin with a **tilted plane** (flat liquid surface orthogonal to gravity).
// offset.x/y provide a small slosh translation; fillA is area proxy in px^2 to control "depth".
function fillBasin(ctx, basin, color, edge, offset, fillA){
  const {gx,gy}=gUnit();            // unit gravity
  const n = {x:-gy, y:gx};          // surface normal (perp to gravity)
  const cx = basin.x+basin.w/2 + offset.ox;
  const cy = basin.y+basin.h/2 + offset.oy;

  // Convert area proxy to an effective "depth" (clamped)
  const maxA = basin.w*basin.h;
  const frac = Math.max(0, Math.min(1, fillA / maxA));
  const depth = Math.max(6, frac * basin.h); // 0..h

  // Build clipping path (the basin shape)
  ctx.save();
  roundRectPath(ctx, basin.x, basin.y, basin.w, basin.h, 10);
  ctx.clip();

  // Build the fill polygon: a big rectangle aligned with the surface line,
  // then shift so the visible depth matches "depth".
  const half = Math.hypot(basin.w,basin.h);
  const px = n.x, py = n.y;
  const sx = -px, sy = -py; // direction "downhill" w.r.t gravity plane
  const k = depth - basin.h/2;

  ctx.beginPath();
  ctx.moveTo(cx + sx*half + px*half, cy + sy*half + py*half + k);
  ctx.lineTo(cx + sx*half - px*half, cy + sy*half - py*half + k);
  ctx.lineTo(cx - sx*half - px*half, cy - sy*half - py*half + k);
  ctx.lineTo(cx - sx*half + px*half, cy - sy*half + py*half + k);
  ctx.closePath();

  ctx.fillStyle=color; ctx.fill();
  ctx.lineWidth=2; ctx.strokeStyle=edge; ctx.stroke();
  ctx.restore();
}

function springTo(s, target, dt){
  // critically-damped-ish 1D spring on the "height" along gravity
  const k = 120*(1-VISC*0.6);         // stiffness (viscosity damps)
  const c = 14 + 60*VISC;             // damping
  const dv = (k*(target - s.oy) - c*s.vel)*dt;
  s.vel += dv;
  s.oy += s.vel*dt;
}

// ------------------ draw/step loop ------------------
function drawScene(){
  ctx.clearRect(0,0,W,H);

  // shelves & pegs
  ctx.save(); ctx.globalAlpha=.55; ctx.fillStyle='rgba(190,200,220,.08)'; ctx.strokeStyle='rgba(255,255,255,.10)'; ctx.lineWidth=2;
  rects.forEach(rc=>{ ctx.fillRect(rc.x,rc.y,rc.w,rc.h); ctx.strokeRect(rc.x+1,rc.y+1,rc.w-2,rc.h-2);});
  pegs.forEach(pg=>{ ctx.beginPath(); ctx.arc(pg.x,pg.y,pg.r,0,Math.PI*2); ctx.fill(); });
  ctx.restore();

  // slosh targets: move the pools slightly downhill
  const {gx,gy}=gUnit();
  const slope = 12; // how far the pool surface shifts visually
  const tgtTop = -slope*gy;   // up near top shelf, move opposite of gravity sign for visual
  const tgtBot =  slope*gy;

  // update springs
  const dtSpring = 1/60;
  springTo(sloshTop, tgtTop, dtSpring);
  springTo(sloshBot, tgtBot, dtSpring);

  // render pools as tilted fills clipped to their basins
  const topBasin={x:topShelf.x, y:topShelf.y-36, w:topShelf.w, h:36};
  const botBasin={x:bottomShelf.x, y:bottomShelf.y-46, w:bottomShelf.w, h:46};

  fillBasin(ctx, topBasin, BLUE, EDGE, sloshTop, massTop*0.45);
  fillBasin(ctx, botBasin, BLUE, EDGE, sloshBot, massBottom*0.55);

  // drops (teardrops)
  drops.forEach(d=>{
    const px=-gy, py=gx, tail=Math.min(d.ry*0.9,12);
    const nx=d.x+gx*(d.ry+tail), ny=d.y+gy*(d.ry+tail), bx=d.x-gx*d.ry, by=d.y-gy*d.ry;
    ctx.beginPath(); ctx.moveTo(bx+px*d.rx, by+py*d.rx);
    ctx.quadraticCurveTo(d.x+px*d.rx, d.y+py*d.rx, nx, ny);
    ctx.quadraticCurveTo(d.x-px*d.rx, d.y-py*d.rx, bx-px*d.rx, by-py*d.rx);
    ctx.closePath(); ctx.fillStyle=BLUE; ctx.strokeStyle=EDGE; ctx.lineWidth=1.6; ctx.fill(); ctx.stroke();
  });

  // HUD
  updDiag();
  hud.textContent = `Top:${Math.round(massTop)} Drops:${Math.round(massDrops)} Bottom:${Math.round(massBottom)} • Visc:${Math.round(VISC*100)} Tens:${Math.round(TENS*100)} Tilt:${DRIP_ON}°`;
}

let last=performance.now();
function loop(now){
  const dt=Math.min(.05,(now-last)/1000); last=now;
  stepDrops(dt);
  drawScene();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
