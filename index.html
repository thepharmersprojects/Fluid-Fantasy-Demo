<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Oil Toy — matched obstacles + tilt drips</title>
<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#cfe7ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header,footer{padding:10px 14px;background:#0e162a;border-bottom:1px solid #1e2b4a}
  footer{border-top:1px solid #1e2b4a;border-bottom:none}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button,input[type=range]{appearance:none;border:none;border-radius:8px;padding:8px 12px;background:#243557;color:#cfe7ff;font-weight:600}
  input[type=range]{width:150px}
  .hint{opacity:.85;font-size:12px}
  #stage{position:relative;width:100%;height:100%;background:linear-gradient(#0b1220,#0b1220 70%,#0a101b)}
  #c{position:absolute;inset:20px;width:calc(100% - 40px);height:calc(100% - 40px);display:block;border-radius:14px;z-index:1}
  .red-sheet{position:absolute;inset:20px;border-radius:14px;pointer-events:none;z-index:3;
    background:linear-gradient(180deg,rgba(215,30,30,.22),rgba(215,30,30,.18));
    mix-blend-mode:multiply;backdrop-filter:blur(1.2px) saturate(115%) brightness(105%);
    box-shadow:0 0 0 1px rgba(120,0,0,.35) inset,0 12px 20px rgba(255,40,40,.06) inset}
  .frame{position:absolute;inset:0;pointer-events:none;z-index:4;border-radius:22px;border:10px solid rgba(255,255,255,.14);
    box-shadow:0 0 0 2px rgba(255,255,255,.10) inset,0 0 0 1px rgba(0,0,0,.55),0 18px 40px rgba(0,0,0,.45);
    background:radial-gradient(120% 100% at 50% -10%,rgba(255,255,255,.18),rgba(255,255,255,0) 55%) border-box,
               radial-gradient(140% 100% at 50% 110%,rgba(255,255,255,.10),rgba(255,255,255,0) 60%) border-box}
  .inner-lip{position:absolute;inset:12px;border-radius:18px;pointer-events:none;z-index:2;
    box-shadow:0 0 0 10px rgba(255,255,255,.04) inset,0 0 0 2px rgba(0,0,0,.45) inset;
    background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.02))}
  #debug{font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#15213a;padding:6px 8px;border-radius:8px;opacity:.95}
  .badge{background:#1e3157;border-radius:8px;padding:6px 8px}
</style>
</head>
<body>
<div id="wrap">
  <header class="row">
    <strong>Oil Toy</strong>
    <button id="enableTilt">Enable Motion</button>
    <label>Drip Rate <input id="rate" type="range" min="0" max="100" value="42"></label>
    <label>Viscosity <input id="visc" type="range" min="0" max="100" value="70"></label>
    <label>Surface Tension <input id="tension" type="range" min="0" max="100" value="65"></label>
    <label>Gravity <input id="gscale" type="range" min="10" max="200" value="85"></label>
    <span class="badge">Mass top:<span id="mt">0</span> • drops:<span id="md">0</span> • bottom:<span id="mb">0</span></span>
    <span id="debug" class="hint">Ready</span>
  </header>

  <div id="stage">
    <canvas id="c"></canvas>
    <div class="inner-lip"></div>
    <div class="red-sheet"></div>
    <div class="frame"></div>
  </div>

  <footer class="row">
    <span class="hint">Match-toy obstacles, top pool drips to bottom pool. Use GitHub Pages (HTTPS) and tap “Enable Motion”.</span>
  </footer>
</div>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W=0,H=0,dpr=1;
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const r=canvas.getBoundingClientRect(); W=r.width; H=r.height;
    canvas.width=Math.floor(W*dpr); canvas.height=Math.floor(H*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    layoutObstacles();
    initFields(); initMass();
  }
  window.addEventListener('resize', resize, {passive:true});

  // ===== Oil behaviour =====
  const OIL='#2a8cff', EDGE='rgba(0,0,0,0.95)';
  const MASS_TOTAL=1000;
  let massTop=0, massBottom=0, massDrops=0;

  let DRIP_RATE=0.42, GRAVITY_SCALE=0.85, VISCOSITY=0.70, TENSION=0.65;
  let gravity={x:0,y:1};

  // Droplets
  const drops=[]; // {x,y,vx,vy,r,m}
  let dropAccumulator=0;

  // Pools (metaball fields)
  let cell=6, cols=0, rows=0, fieldTop=null, fieldBot=null, iso=0.85;
  function initFields(){
    cols=Math.floor((W-40)/cell)+1; rows=Math.floor((H-40)/cell)+1;
    fieldTop=new Float32Array(cols*rows); fieldBot=new Float32Array(cols*rows);
  }
  function initMass(){ massTop=MASS_TOTAL; massBottom=0; massDrops=0; }

  // ===== Obstacles =====
  // Types: pegs (circles), rects (axis aligned), rrects (rotated rect), chains (peg chains)
  const pegs=[], rects=[], rrects=[], chains=[];
  // helpers: pct to px
  const px = (xPct)=> 20 + (W-40)*xPct;
  const py = (yPct)=> 20 + (H-40)*yPct;

  function addPeg(xPct,yPct,rPx){ pegs.push({x:px(xPct), y:py(yPct), r:rPx}); }
  function addRect(xPct,yPct,wPct,hPct){ rects.push({x:px(xPct), y:py(yPct), w:(W-40)*wPct, h:(H-40)*hPct}); }
  function addRotRect(xPct,yPct,wPct,hPct,deg){
    rrects.push({x:px(xPct), y:py(yPct), w:(W-40)*wPct, h:(H-40)*hPct, a:deg*Math.PI/180});
  }
  function addChain(pointsPct, rPx){
    const list = pointsPct.map(([xp,yp])=>({x:px(xp),y:py(yp)}));
    chains.push({pts:list, r:rPx});
  }

  function layoutObstacles(){
    pegs.length=0; rects.length=0; rrects.length=0; chains.length=0;

    // --- TOP SHELF BAR with two gaps
    addRect(0.08, 0.08, 0.84, 0.015); // long bar
    // mask gaps with "antipegs": we'll simply not add extra there; collision uses the bar sides.

    // --- LEFT DIAGONAL STAIRS (3 steps)
    addRotRect(0.22,0.34,0.24,0.018,-28);
    addRotRect(0.26,0.38,0.22,0.018,-28);
    addRotRect(0.30,0.42,0.20,0.018,-28);

    // --- U LOOP near upper middle
    addChain([[0.50,0.26],[0.47,0.29],[0.47,0.32],[0.53,0.32],[0.53,0.29],[0.50,0.26]], 8);

    // --- Twin wavy columns (approx with peg chains)
    addChain([[0.56,0.32],[0.55,0.37],[0.56,0.42],[0.55,0.47]], 7);
    addChain([[0.60,0.32],[0.61,0.37],[0.60,0.42],[0.61,0.47]], 7);

    // --- V funnel
    addRotRect(0.49,0.48,0.16,0.012,15);
    addRotRect(0.51,0.48,0.16,0.012,-15);

    // --- Small H
    addRect(0.50-0.035,0.56,0.07,0.012);
    addRect(0.50-0.035,0.58,0.07,0.012);
    addRect(0.50-0.006,0.56,0.012,0.032);

    // --- Right circle obstacle
    addPeg(0.80,0.60,14);

    // --- Side curly guides (peg chains)
    addChain([[0.18,0.30],[0.14,0.34],[0.16,0.39]], 8);
    addChain([[0.20,0.65],[0.16,0.69],[0.20,0.73]], 8);
    addChain([[0.84,0.32],[0.86,0.37],[0.82,0.41]], 8);

    // --- Bottom shelves and center mound/ramp
    addRect(0.08,0.86,0.35,0.016);
    addRect(0.57,0.86,0.35,0.016);
    addRotRect(0.50,0.82,0.28,0.018,0);        // small shelf above pool
    addRotRect(0.50,0.90,0.22,0.030,0);        // pool lip
    addRotRect(0.50,0.80,0.20,0.020,0);        // mound base
    addRotRect(0.50,0.78,0.16,0.016,0);        // mound top (stepped)
  }

  // ===== Emitter =====
  function nozzle(){ return {x: px(0.52), y: py(0.10)}; }
  function emitDrop(dt){
    if (massTop<=0) return;
    const gm=Math.hypot(gravity.x,gravity.y)||1, gx=gravity.x/gm, gy=gravity.y/gm;
    const downness=Math.max(0, gy*1.0 + Math.abs(gx)*0.15);
    const rate=DRIP_RATE*(0.35+0.65*downness);
    dropAccumulator += rate*dt*120;
    while(dropAccumulator>=1){
      dropAccumulator-=1;
      const m=8+Math.random()*5; if(massTop-m<0) break;
      massTop-=m; massDrops+=m;
      const r=6+(m-8)*0.25;
      const n=nozzle(); const j=(Math.random()-0.5)*3;
      drops.push({x:n.x+j, y:n.y, vx:gx*0.3, vy:gy*0.3, r, m});
    }
  }

  // ===== Metaball pools =====
  const mtEl=document.getElementById('mt'), mdEl=document.getElementById('md'), mbEl=document.getElementById('mb');
  function idx(x,y){ return y*cols + x; }
  function addBlob(field,cx,cy,rad,pow){
    const sx=20, sy=20, r2=rad*rad, inv=1/r2;
    const minx=Math.max(0,Math.floor((cx-rad - sx)/cell));
    const maxx=Math.min(cols-1,Math.ceil ((cx+rad - sx)/cell));
    const miny=Math.max(0,Math.floor((cy-rad - sy)/cell));
    const maxy=Math.min(rows-1,Math.ceil ((cy+rad - sy)/cell));
    for(let gy=miny; gy<=maxy; gy++){
      const gyPos=sy + gy*cell;
      for(let gx=minx; gx<=maxx; gx++){
        const gxPos=sx + gx*cell;
        const dx=gxPos-cx, dy=gyPos-cy, d2=dx*dx+dy*dy;
        if(d2<=r2) field[idx(gx,gy)] += Math.exp(-d2*inv)*pow;
      }
    }
  }
  function buildPoolFields(){
    fieldTop.fill(0); fieldBot.fill(0);
    const k=0.18;
    if(massTop>0){ const r=Math.sqrt(massTop)*k + 28; addBlob(fieldTop, px(0.50), py(0.16), r, 1.35); }
    if(massBottom>0){ const r=Math.sqrt(massBottom)*k + 28; addBlob(fieldBot, px(0.50), py(0.90)-60, r, 1.35); }
  }
  function march(field){
    const paths=[]; 
    for(let y=0;y<rows-1;y++){
      for(let x=0;x<cols-1;x++){
        const a=field[idx(x,y)]>iso?1:0, b=field[idx(x+1,y)]>iso?1:0,
              c=field[idx(x+1,y+1)]>iso?1:0, d=field[idx(x,y+1)]>iso?1:0;
        const state=(a)|(b<<1)|(c<<2)|(d<<3); if(state===0||state===15) continue;
        const fx=t=>20+(x+t)*cell, fy=t=>20+(y+t)*cell;
        const lerp=(f1,f2)=>{const v1=f1-iso,v2=f2-iso;return Math.max(0,Math.min(1,v1/(v1-v2+1e-6)));};
        const f=[field[idx(x,y)],field[idx(x+1,y)],field[idx(x+1,y+1)],field[idx(x,y+1)]];
        const E={top:{x:fx(lerp(f[0],f[1])),y:fy(0)}, right:{x:fx(1),y:fy(lerp(f[1],f[2]))},
                 bottom:{x:fx(lerp(f[3],f[2])),y:fy(1)}, left:{x:fx(0),y:fy(lerp(f[0],f[3]))}};
        switch(state){
          case 1:paths.push([E.left,E.top]);break; case 2:paths.push([E.top,E.right]);break;
          case 3:paths.push([E.left,E.right]);break; case 4:paths.push([E.right,E.bottom]);break;
          case 5:paths.push([E.left,E.top],[E.right,E.bottom]);break; case 6:paths.push([E.top,E.bottom]);break;
          case 7:paths.push([E.left,E.bottom]);break; case 8:paths.push([E.bottom,E.left]);break;
          case 9:paths.push([E.bottom,E.top]);break; case 10:paths.push([E.bottom,E.right],[E.top,E.left]);break;
          case 11:paths.push([E.bottom,E.right]);break; case 12:paths.push([E.right,E.left]);break;
          case 13:paths.push([E.top,E.right]);break; case 14:paths.push([E.left,E.top]);break;
        }
      }
    }
    // stitch
    const map=new Map(); const key=p=>p.x.toFixed(2)+','+p.y.toFixed(2);
    for(const [a,b] of paths){const ka=key(a),kb=key(b); if(!map.has(ka))map.set(ka,[]); if(!map.has(kb))map.set(kb,[]);
      map.get(ka).push(b); map.get(kb).push(a);}
    const visited=new Set(), out=[];
    for(const [start] of map){ if(visited.has(start)) continue;
      const path=[]; let cur=start,prev=null;
      while(cur && !visited.has(cur)){ visited.add(cur); const [x,y]=cur.split(',').map(Number); path.push({x,y});
        const nexts=map.get(cur)||[]; let nxt=null; for(const n of nexts){const nk=key(n); if(nk!==prev){nxt=nk;break;}}
        prev=cur; cur=nxt; }
      if(path.length>2) out.push(path);
    }
    return out;
  }

  // ===== Collisions =====
  function collidePeg(pt,peg){
    const dx=pt.x-peg.x, dy=pt.y-peg.y, d=Math.hypot(dx,dy);
    const minR=peg.r + pt.r*0.8;
    if(d<minR){ const nx=(dx||0.0001)/(d||1), ny=(dy||0.0001)/(d||1); const push=(minR-d);
      pt.x += nx*push; pt.y += ny*push; projectVelAlongGravity(pt); }
  }
  function collideRect(pt,rc){
    const L=rc.x, R=L+rc.w, T=rc.y, B=T+rc.h, pad=pt.r*0.8;
    if(pt.x>L-pad && pt.x<R+pad && pt.y>T-pad && pt.y<B+pad){
      // push out shortest axis
      const dl=Math.abs(pt.x-L), dr=Math.abs(R-pt.x), dt=Math.abs(pt.y-T), db=Math.abs(B-pt.y);
      const m=Math.min(dl,dr,dt,db);
      if(m===dl) pt.x=L-pad; else if(m===dr) pt.x=R+pad;
      else if(m===dt) pt.y=T-pad; else pt.y=B+pad;
      projectVelAlongGravity(pt);
    }
  }
  function collideRotRect(pt,rr){
    // transform pt into rect local space
    const cos=Math.cos(rr.a), sin=Math.sin(rr.a);
    const dx=pt.x-rr.x, dy=pt.y-rr.y;
    const lx =  cos*dx + sin*dy;
    const ly = -sin*dx + cos*dy;
    const hw=rr.w/2, hh=rr.h/2, pad=pt.r*0.8;
    if(lx>-hw-pad && lx<hw+pad && ly>-hh-pad && ly<hh+pad){
      const dl=Math.abs(lx+hw), dr=Math.abs(hw-lx), dt=Math.abs(ly+hh), db=Math.abs(hh-ly);
      let nx=0,ny=0, push=0;
      const m=Math.min(dl,dr,dt,db);
      if(m===dl){ nx=-1; push=(pad-(lx+hw)); }
      else if(m===dr){ nx= 1; push=(pad-(hw-lx)); }
      else if(m===dt){ ny=-1; push=(pad-(ly+hh)); }
      else { ny= 1; push=(pad-(hh-ly)); }
      // back to world
      const wx =  cos*nx - sin*ny, wy = sin*nx + cos*ny;
      pt.x += wx*push; pt.y += wy*push;
      projectVelAlongGravity(pt);
    }
  }
  function collideChain(pt,ch){
    for(const p of ch.pts){ collidePeg(pt,{x:p.x,y:p.y,r:ch.r}); }
  }
  function projectVelAlongGravity(pt){
    const gm=Math.hypot(gravity.x,gravity.y)||1, gx=gravity.x/gm, gy=gravity.y/gm;
    const dot=pt.vx*gx + pt.vy*gy; pt.vx=gx*dot; pt.vy=gy*dot;
  }

  // ===== Step / Draw =====
  function step(dt){
    // gravity
    const gm=Math.hypot(gravity.x,gravity.y)||1, gx=gravity.x/gm*GRAVITY_SCALE, gy=gravity.y/gm*GRAVITY_SCALE;

    // emit
    if(massTop>0) emitDrop(dt);

    // move drops
    for(let i=drops.length-1;i>=0;i--){
      const d=drops[i];
      d.vx=(d.vx + gx*dt) * (1 - VISCOSITY*0.35);
      d.vy=(d.vy + gy*dt) * (1 - VISCOSITY*0.35);
      const sp=Math.hypot(d.vx,d.vy), maxSp=7.0; if(sp>maxSp){ d.vx*=maxSp/sp; d.vy*=maxSp/sp; }
      d.x+=d.vx*dt*60; d.y+=d.vy*dt*60;

      // walls
      const L=20+d.r, T=20+d.r, Rb=W-20-d.r, Bb=H-20-d.r;
      if(d.x<L) d.x=L; if(d.x>Rb) d.x=Rb; if(d.y<T) d.y=T; if(d.y>Bb) d.y=Bb;

      // obstacles
      for(const rc of rects) collideRect(d,rc);
      for(const rr of rrects) collideRotRect(d,rr);
      for(const ch of chains) collideChain(d,ch);
      for(const pg of pegs) collidePeg(d,pg);

      // merge to bottom pool
      const bottomY = py(0.92)-60;
      if(d.y > bottomY - d.r*0.5){
        const absorb=Math.min(d.m, d.m*(0.35+0.65*TENSION));
        d.m-=absorb; massDrops-=absorb; massBottom+=absorb;
        d.r=Math.max(3, d.r*Math.sqrt(Math.max(0.0001,d.m/(d.m+absorb))));
        if(d.m<=0.5){ drops.splice(i,1); continue; }
      }
    }

    // stats & tiny drift correction
    mtEl.textContent=Math.round(massTop); mdEl.textContent=Math.round(massDrops); mbEl.textContent=Math.round(massBottom);
    const sum=massTop+massBottom+massDrops, drift=MASS_TOTAL-sum;
    if(Math.abs(drift)>0.001){ (massBottom>=massTop? (massBottom+=drift):(massTop+=drift)); }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // obstacles visuals
    ctx.save(); ctx.globalAlpha=0.55;
    ctx.fillStyle='rgba(190,200,220,0.08)'; ctx.strokeStyle='rgba(255,255,255,0.10)'; ctx.lineWidth=2;
    for(const rc of rects){ ctx.fillRect(rc.x,rc.y,rc.w,rc.h); ctx.strokeRect(rc.x+1,rc.y+1,rc.w-2,rc.h-2); }
    for(const rr of rrects){
      const c=Math.cos(rr.a), s=Math.sin(rr.a);
      ctx.save(); ctx.translate(rr.x,rr.y); ctx.rotate(rr.a);
      ctx.fillRect(-rr.w/2,-rr.h/2,rr.w,rr.h); ctx.strokeRect(-rr.w/2+1,-rr.h/2+1,rr.w-2,rr.h-2);
      ctx.restore();
    }
    for(const ch of chains){ for(const p of ch.pts){ ctx.beginPath(); ctx.arc(p.x,p.y,ch.r,0,Math.PI*2); ctx.fill(); } }
    for(const pg of pegs){ ctx.beginPath(); ctx.arc(pg.x,pg.y,pg.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();

    // pools
    buildPoolFields();
    function drawField(field){
      const paths=march(field); if(!paths.length) return;
      let best=paths[0], area=-1;
      for(const p of paths){ let a=0; for(let i=0;i<p.length;i++){const j=(i+1)%p.length; a+=p[i].x*p[j].y - p[j].x*p[i].y;}
        a=Math.abs(a)*0.5; if(a>area){area=a; best=p;} }
      ctx.save(); ctx.fillStyle=OIL; ctx.strokeStyle=EDGE; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(best[0].x,best[0].y); for(let i=1;i<best.length;i++) ctx.lineTo(best[i].x,best[i].y);
      ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
    }
    if(massTop>0) drawField(fieldTop);
    if(massBottom>0) drawField(fieldBot);

    // droplets
    ctx.save(); ctx.fillStyle=OIL; ctx.strokeStyle=EDGE; ctx.lineWidth=1.8;
    for(const d of drops){ ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
    ctx.restore();
  }

  // ===== UI / Tilt =====
  const debugEl=document.getElementById('debug'); const setDebug=t=>debugEl.textContent=t;
  ['rate','visc','tension','gscale'].forEach(id=>{
    const el=document.getElementById(id);
    el.addEventListener('input',()=>{
      if(id==='rate') DRIP_RATE=(+el.value)/100;
      if(id==='visc') VISCOSITY=(+el.value)/100;
      if(id==='tension') TENSION=(+el.value)/100;
      if(id==='gscale') GRAVITY_SCALE=(+el.value)/100;
    });
  });
  function isSecure(){ return location.protocol==='https:'||location.hostname==='localhost'||location.hostname==='127.0.0.1'; }
  async function enableMotion(){
    if(!isSecure()) setDebug('Use HTTPS/localhost for tilt.');
    try{
      if(window.DeviceMotionEvent && DeviceMotionEvent.requestPermission){ try{ await DeviceMotionEvent.requestPermission(); }catch{} }
      if(window.DeviceOrientationEvent && DeviceOrientationEvent.requestPermission){ try{ await DeviceOrientationEvent.requestPermission(); }catch{} }
      let got=false;
      window.addEventListener('deviceorientation',e=>{
        const gx=(e.gamma||0)/45, gy=(e.beta||0)/45; gravity.x=gx; gravity.y=gy; got=true;
        setDebug(`gravity: (${(gx*GRAVITY_SCALE).toFixed(2)}, ${(gy*GRAVITY_SCALE).toFixed(2)})`);
      },true);
      window.addEventListener('devicemotion',e=>{
        const a=e.accelerationIncludingGravity||{}; const ax=(a.x||0)/9.81, ay=(a.y||0)/9.81; gravity.x=ax; gravity.y=ay; got=true;
        setDebug(`gravity: (${(ax*GRAVITY_SCALE).toFixed(2)}, ${(ay*GRAVITY_SCALE).toFixed(2)})`);
      },true);
      setTimeout(()=>{ if(!got) setDebug('No sensor events—confirm HTTPS & permissions.'); },1200);
      const btn=document.getElementById('enableTilt'); btn.textContent='Motion Enabled'; btn.disabled=true;
    }catch{ setDebug('Motion permission denied'); }
  }
  document.getElementById('enableTilt').addEventListener('click', enableMotion);

  // ===== Loop =====
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.035,(now-last)/1000); last=now;
    step(dt); draw(); requestAnimationFrame(loop);
  }

  // Start
  resize(); initMass(); requestAnimationFrame(loop);
  if(!isSecure()){ setDebug('Serve over HTTPS (GitHub Pages) then tap “Enable Motion”.'); }
})();
</script>
</body>
</html>
