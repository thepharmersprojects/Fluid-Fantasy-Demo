<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fluid Fantasy – Outlet Neck + Floor-Hugging Pool</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b1420;
    --face1:#c6352b; --face2:#a42e27; --stroke:#7b1f1a;
    --shelf:#eef1f6;
    --oil:#64a8ff;        /* light center */
    --oil-edge:#0f3c89;   /* dark rim */
  }
  html,body{margin:0;background:var(--bg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px}
  .wrap{width:min(430px,92vw)}
  .phone{position:relative;aspect-ratio:9/16;background:linear-gradient(#1a2230,#0c1422);border-radius:28px;box-shadow:0 14px 40px rgba(0,0,0,.55), inset 0 0 0 10px #0e1724;padding:18px}
  canvas{width:100%;height:100%;display:block;border-radius:22px}
  .panel{background:#0f1726;border:1px solid #1e2a42;border-radius:12px;padding:10px 12px;color:#cfd7e7}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin:6px 0}
  input[type=range]{width:52vw;max-width:440px}
  small{color:#9fb0cf}
</style>
</head>
<body>
  <div class="wrap phone"><canvas id="sim"></canvas></div>
  <div class="wrap panel">
    <div class="row"><label>Outlet size</label><input id="out" type="range" min="2" max="18" step="1" value="8"></div>
    <div class="row"><label>Tension (detach mass)</label><input id="ten" type="range" min="0" max="1" step="0.01" value="0.60"></div>
    <div class="row"><label>Viscosity (fall drag)</label><input id="vis" type="range" min="0" max="1" step="0.01" value="0.35"></div>
    <div class="row"><label>Sim Tilt (◀︎/▶︎)</label><input id="tilt" type="range" min="-0.9" max="0.9" step="0.01" value="0"></div>
    <small>Top oil is trapped above the shelf and empties only through the outlet. Neck grows from the pool boundary and pinches off; bottom pool hugs the floor and spreads (no wall column).</small>
  </div>

<script>
(() => {
  // ===== Canvas/setup =====
  const cvs = document.getElementById('sim');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  let W=360, H=640;
  const pad = 20*DPR, rr = 20*DPR;

  const $out = document.getElementById('out');
  const $ten = document.getElementById('ten');
  const $vis = document.getElementById('vis');
  const $tilt= document.getElementById('tilt');

  function resizeCanvas(){
    const b=cvs.getBoundingClientRect();
    W=Math.round(b.width*DPR); H=Math.round(b.height*DPR);
    cvs.width=W; cvs.height=H;
  }

  // ===== World =====
  const world = {
    box:null, shelf:null, outletX:0,
    NX:120, dx:1,
    resH:[],           // reservoir heightfield (above shelf only)
    poolH:[],          // bottom pool heightfield (hugs floor)
    neck:{mass:0,len:0,rad:0}, // neck params
    drops:[],
    outW(){ return parseFloat($out.value)*DPR; },
    init(){
      this.box = {x:pad,y:pad,w:W-2*pad,h:H-2*pad,r:rr};
      const sx=this.box.x+8*DPR, sy=this.box.y+this.box.h*0.16, sw=this.box.w-16*DPR, sh=8*DPR;
      this.shelf={x:sx,y:sy,w:sw,h:sh};
      this.outletX = this.shelf.x + this.shelf.w/2;

      this.dx = this.shelf.w/this.NX;
      const startHead = Math.max(60*DPR, this.shelf.y - (this.box.y+10*DPR));
      this.resH = new Array(this.NX).fill(startHead);
      for(let i=0;i<8;i++){ this.resH[i]*=0.7; this.resH[this.NX-1-i]*=0.7; }

      this.poolH = new Array(this.NX).fill(0);
      this.neck.mass=0; this.neck.len=0; this.neck.rad=0;
      this.drops.length=0;
    }
  };

  // ===== Physics =====
  const DT=1/60, G=900*DPR;
  function gvec(){
    const t=parseFloat($tilt.value);
    const gx=t, gy=1; const m=Math.hypot(gx,gy);
    return {ax:G*gx/m, ay:G*gy/m};
  }
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

  // shallow-water slosh along x, used for top & bottom
  function slosh(H, bias, k){
    const N=H.length, d=new Array(N).fill(0);
    for(let i=0;i<N-1;i++){
      const slope = H[i]-H[i+1];
      const f = k*(slope + bias);
      d[i]   -= f;
      d[i+1] += f;
    }
    for(let i=0;i<N;i++) H[i]=Math.max(0, H[i]+d[i]);
  }

  // spread bottom pool across neighbors (no tall wall “column”), conserve volume
  function levelBottomPool(H){
    const N=H.length;
    // gentle smoothing
    const tmp=H.slice();
    for(let i=1;i<N-1;i++){
      H[i] = (tmp[i-1]+2*tmp[i]+tmp[i+1]) * 0.25;
    }
    // cap steep slopes & absolute height so it hugs the floor
    let sum=0; for(const h of H) sum+=h;
    const avg = sum / N;
    const maxLevel = Math.min(avg*2.4, 0.28*(world.box.h)); // prevents vertical wedge
    for(let i=0;i<N;i++){
      H[i]=Math.min(H[i], maxLevel);
      if(i>0) H[i]=Math.min(H[i], H[i-1]+12*DPR);
    }
  }

  function step(){
    const visc = 0.05 + 1.2*parseFloat($vis.value);
    const tenMul = 0.6 + 1.6*parseFloat($ten.value);
    const {ax,ay} = gvec();
    const bias = ax*0.35;

    // reservoir slosh (above shelf only)
    slosh(world.resH, bias, 0.22);

    // outlet transfer
    const iOut = clamp(Math.floor((world.outletX - world.shelf.x)/world.dx),0,world.NX-1);
    const head = world.resH[iOut];
    if(head>0){
      const A = Math.max(2*DPR, world.outW());
      const c = 0.35;
      const flow = c * A * Math.sqrt(head) * DT;
      world.resH[iOut] = Math.max(0, world.resH[iOut] - (flow/world.dx));
      world.neck.mass += flow;
      world.neck.len   = clamp(world.neck.len + (0.9*DT*DPR + Math.sqrt(head)*0.02), 2*DPR, 34*DPR);
      world.neck.rad   = clamp(world.neck.rad + 0.6*DT*DPR, 2*DPR, 12*DPR);
    } else {
      world.neck.len = Math.max(0, world.neck.len - 10*DT);
      world.neck.rad = Math.max(1*DPR, world.neck.rad - 14*DT);
    }

    // pinch-off criterion
    const detachThresh = (140*DPR*DPR) * tenMul;
    if(world.neck.mass > detachThresh){
      const r = Math.sqrt(world.neck.mass)*0.52;
      world.drops.push({ x:world.outletX, y:world.shelf.y+world.shelf.h/2+world.neck.len+r*0.15, vx:ax*DT*12, vy:40*DPR, r });
      world.neck.mass=0; world.neck.len=world.neck.rad*0.4;
    }

    // advance drops (no bounce)
    const wallL=world.box.x+6*DPR, wallR=world.box.x+world.box.w-6*DPR;
    const floorY=world.box.y+world.box.h-6*DPR;
    for(const d of world.drops){
      d.vx += ax*DT; d.vy += ay*DT;
      d.vx *= (1 - visc*DT); d.vy *= (1 - visc*DT);
      d.x += d.vx*DT; d.y += d.vy*DT;
      if(d.x<wallL){ d.x=wallL; d.vx=0; }
      if(d.x>wallR){ d.x=wallR; d.vx=0; }
      if(d.y>=floorY){
        const i = clamp(Math.floor((d.x - world.shelf.x)/world.dx), 0, world.NX-1);
        const vol = d.r*d.r;
        world.poolH[i] += vol/world.dx;
        d.r=0;
      }
    }
    for(let i=world.drops.length-1;i>=0;i--) if(world.drops[i].r<=0) world.drops.splice(i,1);

    // bottom slosh/spread, then enforce “floor-hugging”
    slosh(world.poolH, bias, 0.35);
    levelBottomPool(world.poolH);
  }

  // ===== Drawing =====
  const css = n => getComputedStyle(document.documentElement).getPropertyValue(n).trim() || (n==='--oil' ? '#64a8ff' : '#0f3c89');

  function rrRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  function drawDevice(){
    const b=world.box;
    const g=ctx.createLinearGradient(0,b.y,0,b.y+b.h);
    g.addColorStop(0,'#d7443b'); g.addColorStop(1,'#a42e27');
    rrRect(ctx,b.x,b.y,b.w,b.h,b.r); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=6*DPR; ctx.strokeStyle='#7b1f1a'; ctx.stroke();
  }

  function drawShelf(){
    const s=world.shelf, rr=s.h/2, gap=world.outW(), gapX=world.outletX-gap/2;
    ctx.save(); ctx.fillStyle=css('--shelf');
    rrRect(ctx,s.x, s.y, gapX-s.x, s.h, rr); ctx.fill();
    rrRect(ctx,gapX+gap, s.y, s.x+s.w-(gapX+gap), s.h, rr); ctx.fill();
    ctx.restore();
  }

  // reservoir polygon with integrated neck (no separate triangle)
  function drawReservoir(){
    const s=world.shelf, x0=s.x, topY=y=> s.y - y;
    let sum=0; for(const h of world.resH) sum+=h; if(sum<=0) return;

    const center=css('--oil'), edge=css('--oil-edge');

    const gap = world.outW();
    const iOut = clamp(Math.floor((world.outletX - x0)/world.dx),0,world.NX-1);
    const neckLen = world.neck.len, neckR = Math.max(1*DPR, world.neck.rad);

    ctx.save();
    ctx.beginPath();
    // left side up to outlet start
    const leftEndX = world.outletX - gap/2;
    const rightStartX = world.outletX + gap/2;

    ctx.moveTo(x0, s.y);
    // trace surface up to gap
    for(let i=0;i<=iOut;i++){
      const x=x0+i*world.dx;
      if(x>leftEndX) break;
      ctx.lineTo(x, topY(world.resH[i]));
    }
    // neck: smoothly go down from pool lip into a bulged ligament and back
    const lipY = s.y; // shelf plane
    ctx.bezierCurveTo(
      leftEndX + gap*0.15, lipY - neckR*0.3,
      world.outletX - neckR*0.6, lipY + neckLen*0.35,
      world.outletX,           lipY + neckLen
    );
    ctx.bezierCurveTo(
      world.outletX + neckR*0.6, lipY + neckLen*0.35,
      rightStartX - gap*0.15, lipY - neckR*0.3,
      rightStartX,            lipY
    );

    // continue tracing surface from right side of gap to the end
    const startJ = Math.floor((rightStartX - x0)/world.dx);
    for(let j=startJ;j<world.NX;j++){
      const x=x0+j*world.dx;
      ctx.lineTo(x, topY(world.resH[j]));
    }
    ctx.lineTo(x0+world.NX*world.dx, s.y);
    ctx.closePath();

    ctx.fillStyle=center; ctx.fill();
    ctx.lineWidth=4*DPR; ctx.strokeStyle=edge; ctx.stroke();
    ctx.restore();

    // bulb hint at the neck end (subtle, not a circle)
    if(neckLen>1){
      const cx=world.outletX, cy=s.y+neckLen;
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy+neckR*0.5, neckR*1.05, neckR*0.85, 0, 0, Math.PI*2);
      ctx.fillStyle=center; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
      ctx.restore();
    }
  }

  function drawBottomPool(){
    const b=world.box, base=b.y+b.h-6*DPR, x0=world.shelf.x;
    let sum=0; for(const h of world.poolH) sum+=h; if(sum<=0) return;

    const center=css('--oil'), edge=css('--oil-edge');
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x0, base);
    for(let i=0;i<world.NX;i++){
      const x=x0+i*world.dx;
      ctx.lineTo(x, base - world.poolH[i]);
    }
    ctx.lineTo(x0+world.NX*world.dx, base);
    ctx.closePath();
    // edge-dark, center-light look
    const lg = ctx.createLinearGradient(x0,0,x0+world.NX*world.dx,0);
    lg.addColorStop(0, edge); lg.addColorStop(0.14, center);
    lg.addColorStop(0.86, center); lg.addColorStop(1, edge);
    ctx.fillStyle=lg; ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=edge; ctx.stroke();
    ctx.restore();
  }

  function drawDrops(){
    const center=css('--oil'), edge=css('--oil-edge');
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=10*DPR;
    for(const d of world.drops){
      const ang=Math.atan2(d.vy,d.vx);
      ctx.beginPath();
      ctx.ellipse(d.x,d.y,d.r*1.12,d.r*0.92,ang,0,Math.PI*2);
      const g=ctx.createRadialGradient(d.x,d.y,0,d.x,d.y,d.r*1.25);
      g.addColorStop(0,center); g.addColorStop(1,edge);
      ctx.fillStyle=g; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
    }
    ctx.restore();
  }

  // ===== Main loop =====
  function frame(){
    step();
    ctx.clearRect(0,0,W,H);
    drawDevice(); drawShelf(); drawBottomPool(); drawDrops(); drawReservoir();
    requestAnimationFrame(frame);
  }

  // boot
  function boot(){ resizeCanvas(); world.init(); requestAnimationFrame(frame); }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', boot); }
  else { boot(); }
  addEventListener('resize', ()=>{ resizeCanvas(); world.init(); });
})();
</script>
</body>
</html>
