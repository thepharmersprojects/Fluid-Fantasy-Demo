<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Fluid Fantasy — Teardrops + Crown Splash</title>
<style>
  :root{
    color-scheme: dark;
    --bg:#0b1420;
    --face1:#c6352b; --face2:#a42e27; --stroke:#7b1f1a;
    --shelf:#eef1f6;
    --oil:#64a8ff;        /* light center */
    --oil-edge:#0f3c89;   /* dark rim */
  }
  html,body{margin:0;background:var(--bg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;display:flex;flex-direction:column;align-items:center;gap:12px}
  .wrap{width:min(430px,92vw)}
  .phone{position:relative;aspect-ratio:9/16;background:linear-gradient(#1a2230,#0c1422);border-radius:28px;box-shadow:0 14px 40px rgba(0,0,0,.55), inset 0 0 0 10px #0e1724;padding:18px}
  canvas{width:100%;height:100%;display:block;border-radius:22px}
  .panel{background:#0f1726;border:1px solid #1e2a42;border-radius:12px;padding:10px 12px;color:#cfd7e7}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px;margin:6px 0}
  input[type=range]{width:52vw;max-width:440px}
  small{color:#9fb0cf}
</style>
</head>
<body>
  <div class="wrap phone"><canvas id="sim"></canvas></div>
  <div class="wrap panel">
    <div class="row"><label>Outlet size</label><input id="out" type="range" min="2" max="18" step="1" value="8"></div>
    <div class="row"><label>Tension (detach mass)</label><input id="ten" type="range" min="0" max="1" step="0.01" value="0.60"></div>
    <div class="row"><label>Viscosity (fall drag)</label><input id="vis" type="range" min="0" max="1" step="0.01" value="0.35"></div>
    <div class="row"><label>Sim Tilt (◀︎/▶︎)</label><input id="tilt" type="range" min="-0.9" max="0.9" step="0.01" value="0"></div>
    <small>Free-fall drops are glossy teardrops. On impact they create a crown splash and ripples, then spread along the floor. No bounce; volume conserved.</small>
  </div>

<script>
(() => {
  const cvs = document.getElementById('sim');
  const ctx = cvs.getContext('2d');
  const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  let W=360,H=640;
  const pad=20*DPR, rr=20*DPR;

  const $out=document.getElementById('out');
  const $ten=document.getElementById('ten');
  const $vis=document.getElementById('vis');
  const $tilt=document.getElementById('tilt');

  function resizeCanvas(){
    const b=cvs.getBoundingClientRect();
    W=Math.round(b.width*DPR); H=Math.round(b.height*DPR);
    cvs.width=W; cvs.height=H;
  }

  const world={
    box:null, shelf:null, outletX:0,
    NX:140, dx:1,
    resH:[], poolH:[], cap:[],
    neck:{mass:0,len:0,rad:0},
    drops:[],
    micro:[],     // tiny ejecta droplets for crown
    splashes:[],  // ring splash ripples
    outW(){ return parseFloat($out.value)*DPR; },
    init(){
      this.box={x:pad,y:pad,w:W-2*pad,h:H-2*pad,r:rr};
      const sx=this.box.x+8*DPR, sy=this.box.y+this.box.h*0.16, sw=this.box.w-16*DPR, sh=8*DPR;
      this.shelf={x:sx,y:sy,w:sw,h:sh};
      this.outletX=this.shelf.x+this.shelf.w/2;

      this.dx=this.shelf.w/this.NX;
      const maxHead = this.shelf.y-(this.box.y+10*DPR);
      this.cap=new Array(this.NX).fill(maxHead);
      const taper=10;
      for(let i=0;i<taper;i++){
        const f=0.65+0.35*i/taper;
        this.cap[i]*=f; this.cap[this.NX-1-i]*=f;
      }
      this.resH=this.cap.map(v=>v*0.9);
      this.poolH=new Array(this.NX).fill(0);
      this.neck.mass=0; this.neck.len=0; this.neck.rad=0;
      this.drops.length=0; this.micro.length=0; this.splashes.length=0;
    }
  };

  // ===== physics =====
  const DT=1/60, G=900*DPR;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function gvec(){
    const t=parseFloat($tilt.value);
    const gx=t, gy=1; const m=Math.hypot(gx,gy);
    return {ax:G*gx/m, ay:G*gy/m};
  }
  function slosh(H,bias,k){
    const N=H.length, d=new Array(N).fill(0);
    for(let i=0;i<N-1;i++){
      const slope=H[i]-H[i+1];
      const f=k*(slope + bias);
      d[i]-=f; d[i+1]+=f;
    }
    for(let i=0;i<N;i++) H[i]=Math.max(0,H[i]+d[i]);
  }
  function enforceCapacity(H, cap, downhillBias){
    const N=H.length;
    for(let pass=0; pass<2; pass++){
      for(let i=0;i<N;i++){
        let over=H[i]-cap[i];
        if(over>0){
          H[i]=cap[i];
          const j1 = clamp(i + (downhillBias>=0? +1 : -1), 0, N-1);
          const j2 = clamp(i + (downhillBias>=0? -1 : +1), 0, N-1);
          const half=over*0.6;
          H[j1]+=half; H[j2]+=over-half;
        }
      }
    }
  }
  function levelBottom(H){
    const N=H.length, src=H.slice();
    for(let i=1;i<N-1;i++) H[i]=(src[i-1]+2*src[i]+src[i+1])*0.25;
    for(let i=1;i<N;i++) H[i]=Math.min(H[i], H[i-1]+12*DPR);
  }

  function step(){
    const visc=0.05+1.2*parseFloat($vis.value);
    const tenMul=0.65+1.6*parseFloat($ten.value);
    const {ax,ay}=gvec();
    const bias=ax*0.35;

    slosh(world.resH,bias,0.22);
    enforceCapacity(world.resH, world.cap, bias);

    // outlet flow
    const iOut=clamp(Math.floor((world.outletX-world.shelf.x)/world.dx),0,world.NX-1);
    const head=world.resH[iOut];
    if(head>0){
      const A=Math.max(2*DPR, world.outW()), c=0.35;
      const flow=c*A*Math.sqrt(head)*DT;
      world.resH[iOut]=Math.max(0, world.resH[iOut]-(flow/world.dx));
      world.neck.mass+=flow;
      world.neck.len = clamp(world.neck.len + (0.9*DT*DPR + Math.sqrt(head)*0.02), 2*DPR, 34*DPR);
      world.neck.rad = clamp(world.neck.rad + 0.6*DT*DPR, 2*DPR, 12*DPR);
    }else{
      world.neck.len=Math.max(0, world.neck.len-10*DT);
      world.neck.rad=Math.max(1*DPR, world.neck.rad-14*DT);
    }

    // pinch-off
    const thresh=(140*DPR*DPR)*tenMul;
    if(world.neck.mass>thresh){
      const r=Math.sqrt(world.neck.mass)*0.52;
      world.drops.push({x:world.outletX,y:world.shelf.y+world.shelf.h/2+world.neck.len+r*0.15,vx:ax*DT*12,vy:40*DPR,r});
      world.neck.mass=0; world.neck.len=world.neck.rad*0.4;
    }

    // advance main drops
    const wallL=world.box.x+6*DPR, wallR=world.box.x+world.box.w-6*DPR;
    const floorY=world.box.y+world.box.h-6*DPR;
    for(const d of world.drops){
      d.vx+=ax*DT; d.vy+=ay*DT;
      d.vx*=(1-visc*DT); d.vy*=(1-visc*DT);
      d.x+=d.vx*DT; d.y+=d.vy*DT;
      if(d.x<wallL){ d.x=wallL; d.vx=0; }
      if(d.x>wallR){ d.x=wallR; d.vx=0; }
      if(d.y>=floorY){
        // deposit volume into pool
        const i=clamp(Math.floor((d.x-world.shelf.x)/world.dx),0,world.NX-1);
        const vol=d.r*d.r; world.poolH[i]+=vol/world.dx;
        // spawn crown splash + micro-ejecta
        spawnSplash(d.x, floorY, Math.min(26*DPR, d.r*1.5), Math.min(8*DPR, d.r*0.5));
        for(let k=0;k<6;k++){
          const ang = (-Math.PI/2) + (Math.random()-0.5)*Math.PI*0.65;
          const spd = (80 + Math.random()*120)*DPR;
          world.micro.push({x:d.x, y:floorY-2*DPR, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, r:Math.max(1.2*DPR, d.r*0.18)});
        }
        d.r=0;
      }
    }
    for(let i=world.drops.length-1;i>=0;i--) if(world.drops[i].r<=0) world.drops.splice(i,1);

    // update micro-drops (re-absorb on bottom)
    for(const m of world.micro){
      m.vx+=ax*DT; m.vy+=ay*DT;
      m.vx*=0.985; m.vy*=0.985;
      m.x+=m.vx*DT; m.y+=m.vy*DT;
      if(m.y>=floorY){
        const i=clamp(Math.floor((m.x-world.shelf.x)/world.dx),0,world.NX-1);
        world.poolH[i]+= (m.r*m.r)/world.dx;
        m.r=0;
      }
    }
    for(let i=world.micro.length-1;i>=0;i--) if(world.micro[i].r<=0) world.micro.splice(i,1);

    // animate splash rings
    for(const s of world.splashes){
      s.t += DT;
      s.r  += s.spread*DT;
      s.amp*= 0.94; // damping
      if(s.amp<0.2) s.dead=true;
      // add a tiny wave into the heightfield
      const cxIndex = clamp(Math.floor((s.x - world.shelf.x)/world.dx),0,world.NX-1);
      const width = Math.max(8, Math.floor(s.r/world.dx));
      for(let k=-width;k<=width;k++){
        const i=cxIndex+k; if(i<0||i>=world.NX) continue;
        const dist = Math.abs(k)*world.dx;
        const w = Math.cos(Math.min(Math.PI, dist/(s.r+1e-3)*Math.PI)); // bell around ring
        world.poolH[i] += s.amp*w*0.015;
      }
    }
    for(let i=world.splashes.length-1;i>=0;i--) if(world.splashes[i].dead) world.splashes.splice(i,1);

    // bottom pool behavior
    slosh(world.poolH, bias, 0.35);
    levelBottom(world.poolH);
  }

  function spawnSplash(x, y, radius, amp){
    world.splashes.push({x, r:radius, amp, spread:120*DPR, t:0, dead:false});
  }

  // ===== drawing =====
  const css = n => getComputedStyle(document.documentElement).getPropertyValue(n).trim() || (n==='--oil' ? '#64a8ff' : '#0f3c89');

  function rrRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }
  function drawDevice(){
    const b=world.box;
    const g=ctx.createLinearGradient(0,b.y,0,b.y+b.h);
    g.addColorStop(0,'#d7443b'); g.addColorStop(1,'#a42e27');
    rrRect(ctx,b.x,b.y,b.w,b.h,b.r); ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=6*DPR; ctx.strokeStyle='#7b1f1a'; ctx.stroke();
  }
  function drawShelf(){
    const s=world.shelf, rr=s.h/2, gap=world.outW(), gapX=world.outletX-gap/2;
    ctx.save(); ctx.fillStyle=css('--shelf');
    rrRect(ctx,s.x, s.y, gapX-s.x, s.h, rr); ctx.fill();
    rrRect(ctx,gapX+gap, s.y, s.x+s.w-(gapX+gap), s.h, rr); ctx.fill();
    ctx.restore();
  }

  // smooth reservoir with c1 neck (no triangle/seam)
  function drawReservoir(){
    const s=world.shelf, x0=s.x;
    const center=css('--oil'), edge=css('--oil-edge');
    let sum=0; for(const h of world.resH) sum+=h; if(sum<=0) return;

    const gap=world.outW(), lipY=s.y, neckLen=world.neck.len, neckR=Math.max(1*DPR, world.neck.rad);

    ctx.save();
    ctx.beginPath();
    // lower to left lip
    ctx.moveTo(x0, lipY);
    ctx.lineTo(world.outletX - gap/2, lipY);
    // neck spline (horizontal tangents at lips)
    const leftLipX = world.outletX - gap/2;
    const rightLipX= world.outletX + gap/2;
    const midX=world.outletX, midY=lipY + neckLen;
    ctx.bezierCurveTo(
      leftLipX + gap*0.25, lipY,
      midX - neckR*0.8,   (lipY*0.35 + midY*0.65),
      midX,               midY
    );
    ctx.bezierCurveTo(
      midX + neckR*0.8,   (lipY*0.35 + midY*0.65),
      rightLipX - gap*0.25, lipY,
      rightLipX,          lipY
    );
    // right surface to wall
    for(let i=Math.floor((rightLipX - x0)/world.dx); i<world.NX; i++){
      const x=x0+i*world.dx, y=lipY - world.resH[i];
      ctx.lineTo(x,y);
    }
    // back to left base and close
    ctx.lineTo(x0+world.NX*world.dx, lipY);
    ctx.lineTo(x0, lipY);
    ctx.closePath();

    ctx.fillStyle=center; ctx.fill();
    ctx.lineWidth=4*DPR; ctx.strokeStyle=edge; ctx.stroke();
    ctx.restore();

    // tiny bulb hint at neck tip
    if(neckLen>1){
      const cx=world.outletX, cy=lipY+neckLen;
      ctx.save();
      ctx.beginPath();
      ctx.ellipse(cx, cy+neckR*0.45, neckR*1.06, neckR*0.88, 0, 0, Math.PI*2);
      ctx.fillStyle=center; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
      ctx.restore();
    }
  }

  function drawBottomPool(){
    const b=world.box, base=b.y+b.h-6*DPR, x0=world.shelf.x;
    let sum=0; for(const h of world.poolH) sum+=h; if(sum<=0) return;
    const center=css('--oil'), edge=css('--oil-edge');

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x0, base);
    for(let i=0;i<world.NX;i++){
      const x=x0+i*world.dx;
      ctx.lineTo(x, base - world.poolH[i]);
    }
    ctx.lineTo(x0+world.NX*world.dx, base);
    ctx.closePath();
    const lg=ctx.createLinearGradient(x0,0,x0+world.NX*world.dx,0);
    lg.addColorStop(0, edge); lg.addColorStop(0.15, center);
    lg.addColorStop(0.85, center); lg.addColorStop(1, edge);
    ctx.fillStyle=lg; ctx.fill();
    ctx.lineWidth=3*DPR; ctx.strokeStyle=edge; ctx.stroke();
    ctx.restore();

    // draw crown rings
    for(const s of world.splashes){
      const opacity = Math.max(0, Math.min(1, s.amp/8));
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.strokeStyle=edge; ctx.lineWidth=2*DPR;
      ctx.beginPath();
      ctx.ellipse(s.x, base-2*DPR, s.r, 6*DPR, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  // glossy teardrop (not a circle) aligned to velocity
  function drawDrops(){
    const center=css('--oil'), edge=css('--oil-edge');
    ctx.save(); ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=10*DPR;

    // main drops
    for(const d of world.drops){
      const ang=Math.atan2(d.vy,d.vx);
      const r=d.r, w=r*1.15, h=r*1.25; // round bottom, sharper top
      ctx.save();
      ctx.translate(d.x,d.y);
      ctx.rotate(ang);
      ctx.beginPath();
      // teardrop with two beziers
      ctx.moveTo(0, -h*0.85);                       // tip
      ctx.bezierCurveTo( +w*0.55, -h*0.40,  +w*0.80, +h*0.10,  0, +h*0.90);
      ctx.bezierCurveTo( -w*0.80, +h*0.10,  -w*0.55, -h*0.40,  0, -h*0.85);
      // fill: radial highlight
      const g=ctx.createRadialGradient(0, -h*0.25, 0, 0, 0, h*1.1);
      g.addColorStop(0, center); g.addColorStop(1, edge);
      ctx.fillStyle=g; ctx.fill();
      ctx.lineWidth=2*DPR; ctx.strokeStyle=edge; ctx.stroke();
      ctx.restore();
    }

    // micro-ejecta
    for(const m of world.micro){
      ctx.beginPath();
      ctx.arc(m.x,m.y,m.r,0,Math.PI*2);
      const g=ctx.createRadialGradient(m.x,m.y,0,m.x,m.y,m.r*1.2);
      g.addColorStop(0, center); g.addColorStop(1, edge);
      ctx.fillStyle=g; ctx.fill();
      ctx.lineWidth=1.5*DPR; ctx.strokeStyle=edge; ctx.stroke();
    }
    ctx.restore();
  }

  // ===== main loop =====
  function frame(){
    step();
    ctx.clearRect(0,0,W,H);
    drawDevice(); drawShelf(); drawBottomPool(); drawDrops(); drawReservoir();
    requestAnimationFrame(frame);
  }

  function boot(){ resizeCanvas(); world.init(); requestAnimationFrame(frame); }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', boot); }
  else { boot(); }
  addEventListener('resize', ()=>{ resizeCanvas(); world.init(); });
})();
</script>
</body>
</html>
