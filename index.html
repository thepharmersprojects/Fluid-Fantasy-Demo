<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Fluid Fantasy — Fixed Canvas</title>
<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#cfe7ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  body{display:flex;flex-direction:column}
  header,footer{background:#0e162a;padding:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button,input[type=range]{appearance:none;border:none;border-radius:8px;padding:8px 12px;background:#243557;color:#cfe7ff;font-weight:700}
  input[type=range]{width:140px}
  label{display:flex;align-items:center;gap:6px;font-size:12px;opacity:.95}
  #hud{opacity:.9}
  #stage{flex:1;display:grid;place-items:center;padding:12px}
  .toy{position:relative;width:360px;height:600px} /* <- FIXED SIZE */
  .red{position:absolute;inset:0;background:#d12a2a;border-radius:24px;box-shadow:0 0 0 2px rgba(0,0,0,.35) inset}
  canvas{position:absolute;inset:0;display:block;width:360px;height:600px;border-radius:24px}
  .frame{position:absolute;inset:-6px;border-radius:30px;border:12px solid rgba(255,255,255,.14);
         box-shadow:0 0 0 2px rgba(255,255,255,.10) inset,0 0 0 1px rgba(0,0,0,.55),0 18px 40px rgba(0,0,0,.45);pointer-events:none}
  footer{border-top:1px solid #1e2b4a}
</style>
</head>
<body>
<header>
  <strong>Fluid Fantasy</strong>
  <label>Visc <input id="visc" type="range" min="0" max="100" value="60"></label>
  <label>Tension <input id="tens" type="range" min="0" max="100" value="70"></label>
  <label>Drip Tilt° <input id="tilt" type="range" min="4" max="30" value="14"></label>
  <label>Sim Tilt <input id="sim" type="range" min="-100" max="100" value="0"></label>
  <span id="hud">Ready</span>
</header>

<div id="stage">
  <div class="toy">
    <div class="red"></div>
    <canvas id="c" width="720" height="1200"></canvas><!-- 2× device pixels -->
    <div class="frame"></div>
  </div>
</div>

<footer><span>Fixed-size canvas: shelves + blue top pool should be visible immediately. Use <b>Sim Tilt</b> to detach drops.</span></footer>

<script>
(()=>{
// --- fixed size constants ---
const W=360, H=600; // CSS pixels (canvas is 2× internally)
const canvas=document.getElementById('c'), ctx=canvas.getContext('2d');
ctx.setTransform(2,0,0,2,0,0); // draw in CSS px (since canvas is 720×1200)

// --- sliders / HUD ---
const hud=document.getElementById('hud');
let VISC=+visc.value/100, TENS=+tens.value/100, DRIP_ON=+tilt.value, DRIP_OFF=Math.max(4,Math.round(DRIP_ON*0.65));
visc.oninput=e=>VISC=+e.target.value/100;
tens.oninput=e=>TENS=+e.target.value/100;
tilt.oninput=e=>{DRIP_ON=+e.target.value;DRIP_OFF=Math.max(4,Math.round(DRIP_ON*0.65));};

// --- obstacles (toy shelves + pegs) ---
const shelves=[], pegs=[]; let topShelf, bottomShelf;
function addShelf(px,py,pw){ const sh={x:W*px, y:H*py, w:W*pw}; shelves.push(sh); return sh; }
function addPeg(px,py,r){ pegs.push({x:W*px, y:H*py, r}); }
(function layout(){
  topShelf    = addShelf(0.08,0.12,0.84);
  addShelf(0.30,0.30,0.22);
  addShelf(0.58,0.40,0.24);
  addShelf(0.18,0.60,0.64);
  bottomShelf = addShelf(0.14,0.86,0.72);
  addPeg(0.62,0.28,12); addPeg(0.70,0.52,10); addPeg(0.48,0.56,8);
})();

// --- oil model (simplified for demo) ---
const BLUE='#2a8cff', EDGE='rgba(0,0,0,.95)';
const MASS_TOTAL=900; let massTop=MASS_TOTAL, massDrops=0, massBottom=0;
const drops=[]; let meniscusPinned=true, dripPhase=0, dropAcc=0;

function gUnit(){ const gx=+sim.value/100; const gy=Math.sqrt(Math.max(0,1-Math.min(1,gx*gx))); const m=Math.hypot(gx,gy)||1; return {gx:gx/m, gy:gy/m}; }
function tiltDegX(){ const {gx}=gUnit(); return Math.asin(Math.abs(gx))*180/Math.PI; }

function emitDrop(dt){
  if (massTop<=0||!topShelf) return;
  const td=tiltDegX();
  if (meniscusPinned&&td>=DRIP_ON) meniscusPinned=false; else if(!meniscusPinned&&td<=DRIP_OFF) meniscusPinned=true;
  dripPhase = meniscusPinned ? Math.max(0,dripPhase-dt*2) : Math.min(1,dripPhase+dt*2);
  if (meniscusPinned||dripPhase<=0) return;

  const {gx,gy}=gUnit(); const down=Math.max(0, gy + Math.abs(gx)*.15);
  dropAcc += (0.25+0.75*down)*dripPhase*(1-TENS*0.5)*dt*120;
  if (dropAcc>=1 && massTop>0){
    dropAcc-=1;
    const m = Math.min(massTop, 8 + 8*TENS);
    massTop -= m; massDrops += m;
    const x = gx>=0 ? (topShelf.x + topShelf.w - 14) : (topShelf.x + 14);
    const y = topShelf.y;
    drops.push({x,y,vx:gx*0.25,vy:gy*0.25,m,rx:6,ry:9});
  }
}

const GRAVITY_SCALE=0.12, PLATE_DRAG=6.0;
function collideShelf(d,sh){
  const t=6, L=sh.x, R=sh.x+sh.w, T=sh.y-t/2, B=sh.y+t/2, r=Math.max(d.rx,d.ry)*.85;
  if (d.x>L-r&&d.x<R+r&&d.y>T-r&&d.y<B+r){ d.y=T-r; d.ry*=.88; d.rx*=1.06; const {gx,gy}=gUnit(); const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot; }
}
function collidePeg(d,pg){
  const dx=d.x-pg.x,dy=d.y-pg.y,dist=Math.hypot(dx,dy),minR=pg.r+Math.max(d.rx,d.ry)*.85;
  if(dist<minR){ const nx=(dx||.001)/(dist||1),ny=(dy||.001)/(dist||1),push=(minR-dist); d.x+=nx*push; d.y+=ny*push; const {gx,gy}=gUnit(); const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot; }
}

function step(dt){
  emitDrop(dt);
  const {gx,gy}=gUnit();
  for (let i=drops.length-1;i>=0;i--){
    const d=drops[i];
    d.vx=(d.vx+gx*GRAVITY_SCALE)*Math.exp(-(VISC*0.9+PLATE_DRAG)*dt);
    d.vy=(d.vy+gy*GRAVITY_SCALE)*Math.exp(-(VISC*0.9+PLATE_DRAG)*dt);
    const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
    d.x+=d.vx*dt*60; d.y+=d.vy*dt*60;
    for (const sh of shelves) collideShelf(d,sh);
    for (const pg of pegs) collidePeg(d,pg);
    if (bottomShelf && d.y>bottomShelf.y-8-d.ry*0.5){
      const ab=Math.min(d.m, d.m*(0.25+0.65*TENS)*0.5);
      d.m-=ab; massDrops-=ab; massBottom+=ab; if (d.m<=.6){ drops.splice(i,1); continue; }
    }
    const sp=Math.hypot(d.vx,d.vy), A=d.m; let elong=Math.max(1.2,1.15+0.6*Math.tanh(sp*0.7));
    let rx=Math.sqrt(A/(Math.PI*elong)), ry=rx*elong; if(ry>10){ ry=10; rx=A/(Math.PI*ry); } d.rx=rx; d.ry=ry;
  }
  const total=massTop+massDrops+massBottom, drift=MASS_TOTAL-total; if(Math.abs(drift)>1e-6){ (massTop>=massBottom?massTop:massBottom)+=drift; }
  hud.textContent=`Top:${Math.round(massTop)} Drops:${Math.round(massDrops)} Bottom:${Math.round(massBottom)}  SimTilt:${sim.value}`;
}

// --- drawing ---
function rr(x,y,w,h,r){const R=Math.min(r,w/2,h/2);ctx.beginPath();ctx.moveTo(x+R,y);ctx.arcTo(x+w,y,x+w,y+h,R);ctx.arcTo(x+w,y+h,x,y+h,R);ctx.arcTo(x,y+h,x,y,R);ctx.arcTo(x,y,x+w,y,R);ctx.closePath();}
function draw(){
  ctx.clearRect(0,0,W,H);
  // shelves
  shelves.forEach(s=>{
    ctx.lineWidth=8; ctx.strokeStyle='rgba(0,0,0,.55)'; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+s.w, s.y); ctx.stroke();
    ctx.lineWidth=4; ctx.strokeStyle='#fff9e6'; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+s.w, s.y); ctx.stroke();
  });
  // pegs
  pegs.forEach(p=>{
    ctx.beginPath(); ctx.lineWidth=8; ctx.strokeStyle='rgba(0,0,0,.55)'; ctx.arc(p.x,p.y,10,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.lineWidth=4; ctx.strokeStyle='#fff9e6'; ctx.arc(p.x,p.y,10,0,Math.PI*2); ctx.stroke();
  });
  // top pool
  if (topShelf){
    const h=Math.max(12, Math.min(90, massTop/30)), x=topShelf.x+10, w=topShelf.w-20, y=topShelf.y - h + 4;
    rr(x,y,w,h,10); ctx.fillStyle=BLUE; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=EDGE; ctx.stroke();
  }
  // bottom pool
  if (bottomShelf){
    const h=Math.max(10, Math.min(120, massBottom/35)), x=bottomShelf.x+12, w=bottomShelf.w-24, y=bottomShelf.y - h + 4;
    rr(x,y,w,h,12); ctx.fillStyle=BLUE; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=EDGE; ctx.stroke();
  }
  // drops
  const {gx,gy}=gUnit();
  drops.forEach(d=>{
    const px=-gy, py=gx, tail=Math.min(d.ry*.9,12);
    const nx=d.x+gx*(d.ry+tail), ny=d.y+gy*(d.ry+tail), bx=d.x-gx*d.ry, by=d.y-gy*d.ry;
    ctx.beginPath(); ctx.moveTo(bx+px*d.rx,by+py*d.rx);
    ctx.quadraticCurveTo(d.x+px*d.rx,d.y+py*d.rx,nx,ny);
    ctx.quadraticCurveTo(d.x-px*d.rx,d.y-py*d.rx,bx-px*d.rx,by-py*d.rx);
    ctx.closePath(); ctx.fillStyle=BLUE; ctx.strokeStyle=EDGE; ctx.lineWidth=1.6; ctx.fill(); ctx.stroke();
  });
}

// --- loop ---
let last=performance.now();
function loop(now){ const dt=Math.min(.05,(now-last)/1000); last=now; step(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
