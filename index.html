<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Fluid Fantasy — Diagnostics + Oil Toy</title>
<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#cfe7ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;overflow:hidden}
  header,footer{position:relative;z-index:1000;display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:12px;background:#0e162a}
  button,input[type=range]{appearance:none;border:none;border-radius:8px;padding:8px 12px;background:#243557;color:#cfe7ff;font-weight:700;touch-action:manipulation;cursor:pointer}
  input[type=range]{width:140px}
  label{display:flex;align-items:center;gap:6px;font-size:12px;opacity:.95}
  #diag{position:relative;z-index:1000;padding:10px 14px;background:#0e162a;border-top:1px solid #1e2b4a}
  #card{background:#132245;border-radius:14px;padding:12px 14px;max-width:520px}
  code{background:#0d1933;padding:2px 6px;border-radius:6px}
  #stage{position:relative;z-index:1;width:100%;height:calc(100vh - 210px)}
  .backplate{position:absolute;inset:20px;border-radius:14px;background:#c42529;box-shadow:0 0 0 1px rgba(0,0,0,.25) inset;pointer-events:none}
  #c{position:absolute;inset:20px;border-radius:14px;width:calc(100% - 40px);height:calc(100% - 40px);display:block;pointer-events:none}
  .redsheet{position:absolute;inset:20px;border-radius:14px;pointer-events:none;background:rgba(215,30,30,.28);box-shadow:0 0 0 1px rgba(120,0,0,.35) inset,0 12px 20px rgba(255,40,40,.06) inset}
  .frame{position:absolute;inset:0;pointer-events:none;border-radius:22px;border:10px solid rgba(255,255,255,.14);box-shadow:0 0 0 2px rgba(255,255,255,.10) inset,0 0 0 1px rgba(0,0,0,.55),0 18px 40px rgba(0,0,0,.45)}
  footer{border-top:1px solid #1e2b4a}
</style>
</head>
<body>

<header>
  <strong>Fluid Fantasy</strong>
  <button id="btnMotion">Enable Motion</button>
  <button id="btnLock">Lock Orientation</button>
  <label>Viscosity <input id="visc" type="range" min="0" max="100" value="75"></label>
  <label>Surface Tension <input id="tension" type="range" min="0" max="100" value="70"></label>
  <label>Drip Tilt° <input id="tiltdeg" type="range" min="4" max="30" value="14"></label>
  <span id="hud" style="margin-left:6px;opacity:.9">Ready</span>
</header>

<div id="diag">
  <div id="card">
    <div>Secure origin (https): <code id="secure">no</code></div>
    <div>Motion events flowing: <code id="motion">no</code></div>
    <div>Gravity (x,y): <code id="g">0.00, 1.00</code></div>
  </div>
</div>

<div id="stage">
  <div class="backplate"></div>
  <canvas id="c"></canvas>
  <div class="redsheet"></div>
  <div class="frame"></div>
</div>

<footer>
  <span>Tip gently. Cross Drip Tilt°: a drop detaches, falls as a teardrop, flattens/merges on shelves. Sliders live-update.</span>
</footer>

<script>
(()=>{
// ---------- Diagnostics / motion ----------
const secure = (location.protocol==='https:'||location.hostname==='localhost'||location.hostname==='127.0.0.1');
document.getElementById('secure').textContent = secure ? 'yes' : 'no';
let motionFlow=false, gravity={x:0,y:1};
function updDiag(){
  document.getElementById('motion').textContent = motionFlow?'yes':'no';
  document.getElementById('g').textContent = `${gravity.x.toFixed(2)}, ${gravity.y.toFixed(2)}`;
}
async function enableMotion(){
  try{
    if (window.DeviceMotionEvent && DeviceMotionEvent.requestPermission) { try{ await DeviceMotionEvent.requestPermission(); }catch{} }
    if (window.DeviceOrientationEvent && DeviceOrientationEvent.requestPermission) { try{ await DeviceOrientationEvent.requestPermission(); }catch{} }
  }catch{}
  addEventListener('deviceorientation', e => { gravity.x=(e.gamma||0)/45; gravity.y=(e.beta||0)/45; motionFlow=true; }, {passive:true});
  addEventListener('devicemotion', e => { const a=e.accelerationIncludingGravity||{}; gravity.x=(a.x||0)/9.81; gravity.y=(a.y||0)/9.81; motionFlow=true; }, {passive:true});
  document.getElementById('btnMotion').textContent='Motion Enabled';
  document.getElementById('btnMotion').disabled=true;
}
document.getElementById('btnMotion').addEventListener('click', enableMotion);

// ---------- Orientation lock (best effort) ----------
document.getElementById('btnLock').addEventListener('click', async ()=>{
  try{
    const stage=document.getElementById('stage');
    if (!document.fullscreenElement && stage.requestFullscreen) await stage.requestFullscreen();
    if (screen.orientation && screen.orientation.lock){
      const t=(screen.orientation.type||'portrait-primary').includes('landscape')?'landscape-primary':'portrait-primary';
      await screen.orientation.lock(t);
    }
  }catch{}
});

// ---------- UI sliders ----------
const hud=document.getElementById('hud');
const viscEl=document.getElementById('visc'), tensEl=document.getElementById('tension'), tiltEl=document.getElementById('tiltdeg');
let VISCOSITY=+viscEl.value/100, SURF_TENSION=+tensEl.value/100, DRIP_TILT_ON=+tiltEl.value, DRIP_TILT_OFF=Math.max(4,Math.round(DRIP_TILT_ON*0.65));
viscEl.oninput=()=>VISCOSITY=+viscEl.value/100;
tensEl.oninput=()=>SURF_TENSION=+tensEl.value/100;
tiltEl.oninput=()=>{DRIP_TILT_ON=+tiltEl.value;DRIP_TILT_OFF=Math.max(4,Math.round(DRIP_TILT_ON*0.65));};

// ---------- Canvas / obstacles ----------
const canvas=document.getElementById('c'), ctx=canvas.getContext('2d');
let W=0,H=0,dpr=1;
function resize(){
  dpr=Math.max(1,Math.min(2,devicePixelRatio||1));
  const r=canvas.getBoundingClientRect(); W=r.width; H=r.height;
  canvas.width=Math.floor(W*dpr); canvas.height=Math.floor(H*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  layout();
}
addEventListener('resize', resize, {passive:true}); resize();

const rects=[], pegs=[]; let topShelf, bottomShelf;
function addRect(px,py,pw,ph){ rects.push({x:20+(W-40)*px, y:20+(H-40)*py, w:(W-40)*pw, h:(H-40)*ph}); }
function addPeg(px,py,r){ pegs.push({x:20+(W-40)*px, y:20+(H-40)*py, r}); }
function layout(){
  rects.length=0; pegs.length=0;
  addRect(0.10,0.12,0.80,0.016); topShelf=rects[rects.length-1];
  addRect(0.30,0.45,0.18,0.016);
  addRect(0.15,0.86,0.70,0.022); bottomShelf=rects[rects.length-1];
  addPeg(0.62,0.30,12); addPeg(0.70,0.54,10); addPeg(0.48,0.60,8);
}

// ---------- Oil model ----------
const OIL='#2a8cff', EDGE='rgba(0,0,0,.95)';
const MASS_TOTAL=900; let massTop=MASS_TOTAL, massDrops=0;
let meniscusPinned=true, dripPhase=0;
const drops=[]; let dropAcc=0;
const GRAVITY_SCALE=0.12, PLATE_DRAG=6.0;

function gUnit(){ const m=Math.hypot(gravity.x,gravity.y)||1; return {gx:gravity.x/m, gy:gravity.y/m}; }
function tiltDegX(){ const {gx}=gUnit(); return Math.asin(Math.min(1,Math.max(-1,Math.abs(gx))))*180/Math.PI; }

const areaFromMass=m=>m;
function radiiFromArea(A,elong){ const rx=Math.sqrt(A/(Math.PI*elong)); return {rx, ry:rx*elong}; }

function drawTear(d){
  const {gx,gy}=gUnit(), px=-gy, py=gx, tail=Math.min(d.ry*0.9,12);
  const nx=d.x+gx*(d.ry+tail), ny=d.y+gy*(d.ry+tail), bx=d.x-gx*d.ry, by=d.y-gy*d.ry;
  ctx.beginPath(); ctx.moveTo(bx+px*d.rx, by+py*d.rx);
  ctx.quadraticCurveTo(d.x+px*d.rx, d.y+py*d.rx, nx, ny);
  ctx.quadraticCurveTo(d.x-px*d.rx, d.y-py*d.rx, bx-px*d.rx, by-py*d.rx);
  ctx.closePath(); ctx.fillStyle=OIL; ctx.strokeStyle=EDGE; ctx.lineWidth=1.6; ctx.fill(); ctx.stroke();
}

function emitDrop(dt){
  if (massTop<=0) return;
  const td=tiltDegX();
  if (meniscusPinned && td>=DRIP_TILT_ON) meniscusPinned=false;
  else if (!meniscusPinned && td<=DRIP_TILT_OFF) meniscusPinned=true;
  dripPhase = meniscusPinned ? Math.max(0,dripPhase-dt*2) : Math.min(1,dripPhase+dt*2);
  if (meniscusPinned||dripPhase<=0) return;

  const L=topShelf.x+12, R=topShelf.x+topShelf.w-12, right=(gUnit().gx>=0);
  const x= right? (R-4):(L+4), y=topShelf.y+topShelf.h/2;

  const {gx,gy}=gUnit(); const down=Math.max(0, gy + Math.abs(gx)*0.15);
  dropAcc += (0.25+0.75*down)*dripPhase*(1-SURF_TENSION*0.5)*dt*120;

  if (dropAcc>=1 && massTop>0){
    dropAcc-=1; const m=Math.min(massTop, 6+10*SURF_TENSION);
    massTop-=m; massDrops+=m; const A=areaFromMass(m);
    let {rx,ry}=radiiFromArea(A,Math.max(1.2,1.35+0.45*Math.abs(gx)+0.35*Math.abs(gy)));
    const RY=10; if (ry>RY){ ry=RY; rx=A/(Math.PI*ry); }
    drops.push({x,y,vx:gx*0.25,vy:gy*0.25,rx,ry,m});
  }
}

function collideRect(d,rc){
  const L=rc.x,R=L+rc.w,T=rc.y,B=T+rc.h,r=Math.max(d.rx,d.ry)*0.85;
  if (d.x>L-r&&d.x<R+r&&d.y>T-r&&d.y<B+r){
    const dl=Math.abs(d.x-L),dr=Math.abs(R-d.x),dt=Math.abs(d.y-T),db=Math.abs(B-d.y);
    const m=Math.min(dl,dr,dt,db);
    if (m===dt){ d.y=T-r; d.ry*=0.88; d.rx*=1.06;
      const ab=Math.min(d.m,d.m*(0.20+0.60*SURF_TENSION)*0.3);
      d.m-=ab; massDrops-=ab; massTop+=ab; if (d.m<=0.6) return 'rm';
    } else if (m===db){ d.y=B+r; }
    else if (m===dl){ d.x=L-r; } else { d.x=R+r; }
    const {gx,gy}=gUnit(); const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
  }
}

function collidePeg(d,pg){
  const dx=d.x-pg.x, dy=d.y-pg.y, dist=Math.hypot(dx,dy), minR=pg.r+Math.max(d.rx,d.ry)*0.85;
  if (dist<minR){
    const nx=(dx||.001)/(dist||1), ny=(dy||.001)/(dist||1), push=(minR-dist);
    d.x+=nx*push; d.y+=ny*push; const {gx,gy}=gUnit(); const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
  }
}

function step(dt){
  emitDrop(dt);
  const {gx,gy}=gUnit();
  for (let i=drops.length-1;i>=0;i--){
    const d=drops[i];
    d.vx=(d.vx+gx*GRAVITY_SCALE)*Math.exp(-(VISCOSITY*0.9+PLATE_DRAG)*dt);
    d.vy=(d.vy+gy*GRAVITY_SCALE)*Math.exp(-(VISCOSITY*0.9+PLATE_DRAG)*dt);
    const dot=d.vx*gx+d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
    d.x+=d.vx*dt*60; d.y+=d.vy*dt*60;
    const pad=Math.max(d.rx,d.ry)*0.85;
    if (d.x<20+pad) d.x=20+pad; if (d.x>W+20-pad) d.x=W+20-pad;
    if (d.y<20+pad) d.y=20+pad; if (d.y>H+20-pad) d.y=H+20-pad;
    for (const rc of rects){ if (collideRect(d,rc)==='rm'){ drops.splice(i,1); continue; } }
    for (const pg of pegs){ collidePeg(d,pg); }
    const bottomY=bottomShelf.y-4;
    if (d.y>bottomY-d.ry*0.5){
      const ab=Math.min(d.m,d.m*(0.25+0.65*SURF_TENSION)*0.5);
      d.m-=ab; massDrops-=ab; massTop+=ab; if (d.m<=0.6){ drops.splice(i,1); continue; }
    }
    const sp=Math.hypot(d.vx,d.vy), A=areaFromMass(d.m);
    let {rx,ry}=radiiFromArea(A,Math.max(1.2,1.15+0.6*Math.tanh(sp*0.7)));
    const RY=10; if (ry>RY){ ry=RY; rx=A/(Math.PI*ry); } d.rx=rx; d.ry=ry;
  }
  // conserve mass
  const total=massTop+massDrops, drift=MASS_TOTAL-total;
  if (Math.abs(drift)>1e-6){ if (massTop>=massDrops) massTop+=drift; else massDrops+=drift; }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.save(); ctx.globalAlpha=.55; ctx.fillStyle='rgba(190,200,220,.08)'; ctx.strokeStyle='rgba(255,255,255,.10)'; ctx.lineWidth=2;
  rects.forEach(rc=>{ ctx.fillRect(rc.x,rc.y,rc.w,rc.h); ctx.strokeRect(rc.x+1,rc.y+1,rc.w-2,rc.h-2);});
  pegs.forEach(pg=>{ ctx.beginPath(); ctx.arc(pg.x,pg.y,pg.r,0,Math.PI*2); ctx.fill(); });
  ctx.restore();

  const poolW=bottomShelf.w*.9, poolH=Math.max(18,Math.min(90,massTop/40));
  const poolX=bottomShelf.x+(bottomShelf.w-poolW)/2, poolY=bottomShelf.y+bottomShelf.h-poolH;
  ctx.save(); ctx.fillStyle=OIL; ctx.strokeStyle=EDGE; ctx.lineWidth=2;
  roundRect(ctx,poolX,poolY,poolW,poolH,12); ctx.fill(); ctx.stroke(); ctx.restore();

  drops.forEach(drawTear);
  updDiag();
  hud.textContent = `Top:${Math.round(massTop)} Drops:${Math.round(massDrops)} Visc:${Math.round(VISCOSITY*100)} Tens:${Math.round(SURF_TENSION*100)} DripTilt:${DRIP_TILT_ON}° motion:${motionFlow?'yes':'no'}`;
}
function roundRect(ctx,x,y,w,h,r){const rr=Math.min(r,w/2,h/2);ctx.beginPath();ctx.moveTo(x+rr,y);ctx.arcTo(x+w,y,x+w,y+h,rr);ctx.arcTo(x+w,y+h,x,y+h,rr);ctx.arcTo(x,y+h,x,y,rr);ctx.arcTo(x,y,x+w,y,rr);ctx.closePath();}

let last=performance.now();
function loop(now){ const dt=Math.min(.05,(now-last)/1000); last=now; step(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
})();
</script>
</body>
</html>
