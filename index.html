<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Oil Toy — Thin Film Demo (sliders, obstacles, orientation lock)</title>
<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#cfe7ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}
  header,footer{padding:10px 14px;background:#0e162a;border-bottom:1px solid #1e2b4a}
  footer{border-top:1px solid #1e2b4a;border-bottom:none}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  button,input[type=range]{appearance:none;border:none;border-radius:8px;padding:8px 12px;background:#243557;color:#cfe7ff;font-weight:600}
  input[type=range]{width:140px}
  label{display:flex;align-items:center;gap:6px;font-size:12px;opacity:.95}
  .hint{opacity:.85;font-size:12px}

  #stage{position:relative;width:100%;height:100%}
  .backplate{position:absolute;inset:20px;border-radius:14px;z-index:0;background:#c42529;box-shadow:0 0 0 1px rgba(0,0,0,.25) inset}
  #c{position:absolute;inset:20px;border-radius:14px;width:calc(100% - 40px);height:calc(100% - 40px);display:block;z-index:1}
  .redsheet{position:absolute;inset:20px;border-radius:14px;pointer-events:none;z-index:3;background:rgba(215,30,30,.28);backdrop-filter:blur(1.2px) saturate(115%) brightness(105%);box-shadow:0 0 0 1px rgba(120,0,0,.35) inset,0 12px 20px rgba(255,40,40,.06) inset}
  .frame{position:absolute;inset:0;pointer-events:none;z-index:4;border-radius:22px;border:10px solid rgba(255,255,255,.14);box-shadow:0 0 0 2px rgba(255,255,255,.10) inset,0 0 0 1px rgba(0,0,0,.55),0 18px 40px rgba(0,0,0,.45);background:radial-gradient(120% 100% at 50% -10%,rgba(255,255,255,.18),rgba(255,255,255,0) 55%) border-box,radial-gradient(140% 100% at 50% 110%,rgba(255,255,255,.10),rgba(255,255,255,0) 60%) border-box}
  #hud{font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#15213a;padding:6px 8px;border-radius:8px;opacity:.95}
</style>
</head>
<body>
<div id="wrap">
  <header class="row">
    <strong>Oil Toy</strong>
    <button id="enableTilt">Enable Motion</button>
    <button id="lockOrientation">Lock Orientation</button>
    <label>Viscosity <input id="visc" type="range" min="0" max="100" value="75"></label>
    <label>Surface Tension <input id="tension" type="range" min="0" max="100" value="70"></label>
    <label>Drip Tilt° <input id="tiltdeg" type="range" min="4" max="30" value="14"></label>
    <span id="hud">Ready</span>
  </header>

  <div id="stage">
    <div class="backplate"></div>
    <canvas id="c"></canvas>
    <div class="redsheet"></div>
    <div class="frame"></div>
  </div>

  <footer class="row">
    <span class="hint">Tip gently: pool pins. Cross Drip Tilt°: one drop detaches, falls as a teardrop, flattens/merges on shelves. Sliders live-update.</span>
  </footer>
</div>

<script>
(() => {
  // ===== Canvas
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W=0,H=0,dpr=1;
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const r=canvas.getBoundingClientRect(); W=r.width; H=r.height;
    canvas.width=Math.floor(W*dpr); canvas.height=Math.floor(H*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    layoutObstacles();
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ===== UI
  const hud = document.getElementById('hud');
  const viscEl = document.getElementById('visc');
  const tensEl = document.getElementById('tension');
  const tiltEl = document.getElementById('tiltdeg');

  let VISCOSITY = (+viscEl.value)/100;     // 0..1
  let SURF_TENSION = (+tensEl.value)/100;  // 0..1
  let DRIP_TILT_ON = +tiltEl.value;        // degrees
  let DRIP_TILT_OFF = Math.max(4, Math.round(DRIP_TILT_ON*0.65)); // hysteresis

  viscEl.addEventListener('input', ()=>{ VISCOSITY = (+viscEl.value)/100; });
  tensEl.addEventListener('input', ()=>{ SURF_TENSION = (+tensEl.value)/100; });
  tiltEl.addEventListener('input', ()=>{
    DRIP_TILT_ON = +tiltEl.value;
    DRIP_TILT_OFF = Math.max(4, Math.round(DRIP_TILT_ON*0.65));
  });

  // ===== Orientation lock (best-effort; iOS may still require Control Center lock)
  document.getElementById('lockOrientation').addEventListener('click', async ()=>{
    try{
      const stage = document.getElementById('stage');
      if (document.fullscreenElement == null && stage.requestFullscreen) { await stage.requestFullscreen(); }
      if (screen.orientation && screen.orientation.lock){
        const prefer = (screen.orientation.type||'portrait-primary').includes('landscape')? 'landscape-primary':'portrait-primary';
        await screen.orientation.lock(prefer);
        hud.textContent = 'Orientation locked';
      } else {
        hud.textContent = 'If rotation persists, use iOS Control Center rotation lock.';
      }
    }catch(e){
      hud.textContent = 'Lock failed. Use iOS rotation lock.';
    }
  });

  // ===== Motion / Gravity
  let gravity = {x:0,y:1};
  function gUnit(){ const m=Math.hypot(gravity.x,gravity.y)||1; return {gx:gravity.x/m, gy:gravity.y/m}; }
  function tiltDegreesAlongX(){
    const {gx} = gUnit();
    return Math.asin(Math.max(-1,Math.min(1,Math.abs(gx))))*180/Math.PI;
  }
  function isSecure(){ return location.protocol==='https:'||location.hostname==='localhost'||location.hostname==='127.0.0.1'; }
  async function enableMotion(){
    if(!isSecure()) hud.textContent='Use HTTPS/localhost for tilt.';
    try{
      if(window.DeviceMotionEvent && DeviceMotionEvent.requestPermission){ try{ await DeviceMotionEvent.requestPermission(); }catch{} }
      if(window.DeviceOrientationEvent && DeviceOrientationEvent.requestPermission){ try{ await DeviceOrientationEvent.requestPermission(); }catch{} }
      let got=false;
      window.addEventListener('deviceorientation',e=>{
        const gx=(e.gamma||0)/45, gy=(e.beta||0)/45; gravity.x=gx; gravity.y=gy; got=true;
      },true);
      window.addEventListener('devicemotion',e=>{
        const a=e.accelerationIncludingGravity||{}; const ax=(a.x||0)/9.81, ay=(a.y||0)/9.81; gravity.x=ax; gravity.y=ay; got=true;
      },true);
      setTimeout(()=>{ if(!got) hud.textContent='No sensor events—confirm HTTPS & permissions.'; },1200);
      const btn=document.getElementById('enableTilt'); btn.textContent='Motion Enabled'; btn.disabled=true;
    }catch{ hud.textContent='Motion permission denied'; }
  }
  document.getElementById('enableTilt').addEventListener('click', enableMotion);

  // ===== Oil constants / state
  const OIL='#2a8cff', EDGE='rgba(0,0,0,0.95)';
  const MASS_TOTAL=900;
  let massTop=MASS_TOTAL, massDrops=0;
  let meniscusPinned=true, dripPhase=0; // 0..1 ramp

  // Droplets (thin-film teardrops)
  const drops=[]; // {x,y,vx,vy,rx,ry,m}
  let dropAccumulator=0;
  const GRAVITY_SCALE=0.12;

  // ===== Obstacles (simple course to test)
  const rects=[]; const pegs=[];
  function addRect(xPct,yPct,wPct,hPct){ rects.push({x:20+(W-40)*xPct, y:20+(H-40)*yPct, w:(W-40)*wPct, h:(H-40)*hPct}); }
  function addPeg(xPct,yPct,rPx){ pegs.push({x:20+(W-40)*xPct, y:20+(H-40)*yPct, r:rPx}); }
  let topShelf = null, midShelf = null, bottomShelf = null;
  function layoutObstacles(){
    rects.length=0; pegs.length=0;
    // Top wide shelf (rim where drip forms)
    addRect(0.10,0.12,0.80,0.016); topShelf = rects[rects.length-1];
    // Mid small shelf (catch & flatten)
    addRect(0.30,0.45,0.18,0.016); midShelf = rects[rects.length-1];
    // Bottom shelf (pool)
    addRect(0.15,0.86,0.70,0.022); bottomShelf = rects[rects.length-1];
    // Pegs as deflectors
    addPeg(0.62,0.30,12);
    addPeg(0.70,0.54,10);
    addPeg(0.48,0.60,8);
  }

  // ===== Helpers
  function areaFromMass(m){ return m; }
  function radiiFromArea(A,elong=1){
    const rx = Math.sqrt(A / (Math.PI * elong));
    return {rx, ry: rx*elong};
  }
  function drawTearDrop(ctx, d){
    const {gx, gy} = gUnit(), px = -gy, py = gx;
    const tail = Math.min(d.ry * 0.9, 12); // thin-film tail
    const noseX = d.x + gx * (d.ry + tail), noseY = d.y + gy * (d.ry + tail);
    const buttX = d.x - gx * d.ry,         buttY = d.y - gy * d.ry;
    ctx.beginPath();
    ctx.moveTo(buttX + px*d.rx, buttY + py*d.rx);
    ctx.quadraticCurveTo(d.x + px*d.rx, d.y + py*d.rx, noseX, noseY);
    ctx.quadraticCurveTo(d.x - px*d.rx, d.y - py*d.rx, buttX - px*d.rx, buttY - py*d.rx);
    ctx.closePath();
    ctx.fillStyle = OIL; ctx.strokeStyle = EDGE; ctx.lineWidth = 1.6; ctx.fill(); ctx.stroke();
  }

  // ===== Drip emission (pinned → unpinned based on tilt + hysteresis)
  function emitDrop(dt){
    if (massTop<=0) return;

    const tiltDeg = tiltDegreesAlongX();
    if (meniscusPinned){
      if (tiltDeg >= DRIP_TILT_ON) meniscusPinned = false;
    } else {
      if (tiltDeg <= DRIP_TILT_OFF) meniscusPinned = true;
    }

    if (!meniscusPinned) dripPhase = Math.min(1, dripPhase + dt*2.0);
    else                 dripPhase = Math.max(0, dripPhase - dt*2.0);

    if (meniscusPinned || dripPhase<=0) return;

    // rim position near edge chosen by tilt direction
    const L = topShelf.x + 12, R = topShelf.x + topShelf.w - 12;
    const towardRight = (gUnit().gx >= 0);
    const x = towardRight ? (R - 4) : (L + 4);
    const y = topShelf.y + topShelf.h/2;

    // rate depends on gravity component and surface tension
    const {gx, gy} = gUnit();
    const downness = Math.max(0, gy*1.0 + Math.abs(gx)*0.15);
    const baseRate = (0.25 + 0.75*downness) * dripPhase;
    dropAccumulator += baseRate * (1 - SURF_TENSION*0.5) * dt * 120;

    while (dropAccumulator >= 1 && massTop > 0){
      dropAccumulator -= 1;
      // higher surface tension → larger drops (cling longer)
      const m = Math.min(massTop, 6 + 10*SURF_TENSION); // 6..16
      massTop -= m; massDrops += m;
      const A = areaFromMass(m);
      const elong = Math.max(1.2, 1.35 + 0.45*Math.abs(gx) + 0.35*Math.abs(gy));
      let {rx, ry} = radiiFromArea(A, elong);
      // thin-film cap on minor axis (squeezed look)
      const RY_MAX = 10; if (ry > RY_MAX){ ry = RY_MAX; rx = A/(Math.PI*ry); }
      drops.push({x, y, vx: gx*0.25, vy: gy*0.25, rx, ry, m});
      break; // one per frame max
    }
  }

  // ===== Collisions
  function collideRect(d, rc){
    const L=rc.x, R=L+rc.w, T=rc.y, B=T+rc.h;
    const r = Math.max(d.rx, d.ry) * 0.85; // padding
    if (d.x > L-r && d.x < R+r && d.y > T-r && d.y < B+r){
      const dl=Math.abs(d.x-L), dr=Math.abs(R-d.x), dt=Math.abs(d.y-T), db=Math.abs(B-d.y);
      const m = Math.min(dl,dr,dt,db);
      if (m===dt){ // top face (shelf)
        d.y = T - r;
        // flatten (thin film)
        d.ry *= 0.88; d.rx *= 1.06;
        // absorb slowly (simulate film pooling)
        const absorb = Math.min(d.m, d.m * (0.20 + 0.60*SURF_TENSION) * 0.3);
        d.m -= absorb; massDrops -= absorb; massTop += absorb;
        if (d.m <= 0.6){ return 'remove'; }
      } else if (m===db){ d.y = B + r; }
      else if (m===dl){ d.x = L - r; }
      else { d.x = R + r; }
      // slide along gravity
      const {gx, gy} = gUnit(); const dot=d.vx*gx + d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
    }
  }
  function collidePeg(d, pg){
    const dx=d.x-pg.x, dy=d.y-pg.y, dist=Math.hypot(dx,dy);
    const minR = pg.r + Math.max(d.rx,d.ry)*0.85;
    if (dist < minR){
      const nx=(dx||0.001)/(dist||1), ny=(dy||0.001)/(dist||1);
      const push=(minR-dist);
      d.x += nx*push; d.y += ny*push;
      const {gx, gy} = gUnit(); const dot=d.vx*gx + d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;
    }
  }

  // ===== Physics Step
  function step(dt){
    emitDrop(dt);
    const {gx, gy} = gUnit();

    // move drops
    for (let i=drops.length-1;i>=0;i--){
      const d=drops[i];
      // gravity + damping: viscosity + plate drag (thin-film feel)
      const PLATE_DRAG = 6.0; // fixed plate drag
      d.vx = (d.vx + gx*GRAVITY_SCALE) * Math.exp(-(VISCOSITY*0.9 + PLATE_DRAG)*dt);
      d.vy = (d.vy + gy*GRAVITY_SCALE) * Math.exp(-(VISCOSITY*0.9 + PLATE_DRAG)*dt);

      // strictly along gravity
      const dot=d.vx*gx + d.vy*gy; d.vx=gx*dot; d.vy=gy*dot;

      // integrate
      d.x += d.vx * dt * 60;
      d.y += d.vy * dt * 60;

      // bounds
      const pad=Math.max(d.rx,d.ry)*0.85;
      if (d.x < 20+pad) d.x = 20+pad;
      if (d.x > W+20-pad) d.x = W+20-pad;
      if (d.y < 20+pad) d.y = 20+pad;
      if (d.y > H+20-pad) d.y = H+20-pad;

      // obstacles
      let removed=false;
      for (const rc of rects){ if (collideRect(d, rc)==='remove'){ drops.splice(i,1); removed=true; break; } }
      if (removed) continue;
      for (const pg of pegs){ collidePeg(d, pg); }

      // bottom shelf merge if near it
      const bottomY = bottomShelf.y - 4;
      if (d.y > bottomY - d.ry*0.5){
        const absorb = Math.min(d.m, d.m*(0.25 + 0.65*SURF_TENSION)*0.5);
        d.m -= absorb; massDrops -= absorb; massTop += absorb;
        if (d.m<=0.6){ drops.splice(i,1); continue; }
      }

      // keep area tied to mass, deform by speed (teardrop)
      const sp = Math.hypot(d.vx, d.vy);
      const elong = Math.max(1.2, 1.15 + 0.6 * Math.tanh(sp*0.7));
      const A = areaFromMass(d.m);
      let r = radiiFromArea(A, elong);
      // thin-film cap
      const RY_MAX = 10; if (r.ry > RY_MAX){ r.ry = RY_MAX; r.rx = A/(Math.PI*r.ry); }
      d.rx = r.rx; d.ry = r.ry;
    }

    // mass conservation shim
    const total = massTop + massDrops;
    const drift = MASS_TOTAL - total;
    if (Math.abs(drift)>1e-6){ if (massTop >= massDrops) massTop += drift; else massDrops += drift; }
  }

  // ===== Draw
  function draw(){
    ctx.clearRect(0,0,W,H);

    // Obstacles visuals
    ctx.save(); ctx.globalAlpha=0.55;
    ctx.fillStyle='rgba(190,200,220,0.08)'; ctx.strokeStyle='rgba(255,255,255,0.10)'; ctx.lineWidth=2;
    for(const rc of rects){ ctx.fillRect(rc.x,rc.y,rc.w,rc.h); ctx.strokeRect(rc.x+1,rc.y+1,rc.w-2,rc.h-2); }
    for(const pg of pegs){ ctx.beginPath(); ctx.arc(pg.x,pg.y,pg.r,0,Math.PI*2); ctx.fill(); }
    ctx.restore();

    // Bottom pool (simple lens tied to massTop)
    const poolW = bottomShelf.w*0.9;
    const poolH = Math.max(18, Math.min(90, massTop/40));
    const poolX = bottomShelf.x + (bottomShelf.w - poolW)/2;
    const poolY = bottomShelf.y + bottomShelf.h - poolH;
    ctx.save(); ctx.fillStyle=OIL; ctx.strokeStyle=EDGE; ctx.lineWidth=2;
    roundRect(ctx, poolX, poolY, poolW, poolH, 12); ctx.fill(); ctx.stroke(); ctx.restore();

    // Drops
    for (const d of drops) drawTearDrop(ctx, d);

    // HUD
    hud.textContent = `Top:${Math.round(massTop)}  Drops:${Math.round(massDrops)}  Total:${Math.round(massTop+massDrops)}  Visc:${Math.round(VISCOSITY*100)}  Tension:${Math.round(SURF_TENSION*100)}  DripTilt:${DRIP_TILT_ON}°`;
  }

  function roundRect(ctx,x,y,w,h,r){const rr=Math.min(r,w/2,h/2);ctx.beginPath();ctx.moveTo(x+rr,y);ctx.arcTo(x+w,y,x+w,y+h,rr);ctx.arcTo(x+w,y+h,x,y+h,rr);ctx.arcTo(x,y+h,x,y,rr);ctx.arcTo(x,y,x+w,y,rr);ctx.closePath();}

  // ===== Loop
  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.05,(now-last)/1000); last=now;
    step(dt); draw(); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
