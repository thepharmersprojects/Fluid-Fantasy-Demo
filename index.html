<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Fluid Fantasy — Wham‑O style (portrait)</title>
<style>
  :root{
    --glass-red:#c42727;
    --rim:#ffffff;
    --oil:#1b6cad;
    --ui:rgba(255,255,255,0.92);
  }
  html,body{height:100%;margin:0;background:#111;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #wrap{height:100%;display:flex;align-items:center;justify-content:center}
  canvas{touch-action:none}
  #ui{
    position:fixed;top:12px;left:12px;right:12px;display:flex;justify-content:space-between;gap:8px;pointer-events:none;
  }
  .btn{
    pointer-events:auto;border:0;border-radius:14px;padding:10px 14px;background:var(--ui);
    font-weight:600;box-shadow:0 2px 16px rgba(0,0,0,.25);cursor:pointer
  }
  #hint{position:fixed;bottom:10px;left:0;right:0;text-align:center;color:#fff;opacity:.85;font-size:13px}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas" width="900" height="1600"></canvas>
</div>
<div id="ui">
  <button id="fsBtn" class="btn">Enter Fullscreen</button>
  <button id="resetBtn" class="btn">Reset</button>
</div>
<div id="hint">Wham‑O style • Tilt to flow • Double‑tap to flip</div>

<script>
(() => {
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Logical canvas size (portrait phone)
  const W = 360, H = 640;
  const RIM = 18;          // white bezel thickness
  const GLASS = 10;        // red glass inset from rim

  // Inner playable rect
  const minX = RIM + GLASS, maxX = W - RIM - GLASS;
  const minY = RIM + GLASS, maxY = H - RIM - GLASS;

  // Resize to fit screen
  function fit() {
    const pad = 8;
    const aw = innerWidth - pad*2, ah = innerHeight - pad*2;
    const aspect = W/H;
    let vw = aw, vh = vw/aspect;
    if (vh > ah) { vh = ah; vw = vh*aspect; }
    canvas.style.width = vw + 'px';
    canvas.style.height = vh + 'px';
    canvas.width = Math.round(W*DPR);
    canvas.height = Math.round(H*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  fit(); addEventListener('resize', fit);

  // Obstacles (white bars/pegs)
  const bars = [
    [minX+12, 110, maxX-80, 110],
    [minX+36, 170, minX+220, 170],
    [minX+28, 300, minX+210, 300],
    [maxX-100, 360, maxX-20, 360],
    [minX+10, H-110, maxX-10, H-110],
  ];
  const pegs = [
    {x:minX+255, y:110, r:7},
    {x:minX+270, y:110, r:7},
    {x:minX+248, y:150, r:7},
    {x:minX+270, y:220, r:8},
  ];

  // Fluid parameters (globby, slow)
  const N = 140;                 // droplets
  const PR = 5.5;                // render radius
  const SR = 30;                 // neighbor radius
  const COHESION = 0.70;         // surface tension
  const REPULSION = 1100;        // core repulsion
  const VISCOSITY = 0.35;        // thickness
  const AIR_DRAG = 0.06;         // global damping
  const WALL_FRICTION = 0.35;    // slide slowly
  const BOUNCE = 30;             // tiny bounce

  // Gravity via tilt
  const G0 = 380;                // accel scale
  let g = {x:0, y:1};
  let gravityFlip = 1;

  function handleTilt(e){
    const beta  = (e.beta  || 0) * Math.PI/180;
    const gamma = (e.gamma || 0) * Math.PI/180;
    let gx = Math.sin(gamma);
    let gy = Math.sin(beta);
    const m = Math.hypot(gx, gy) || 1e-6;
    gx /= m; gy /= m;
    g.x = gx * gravityFlip;
    g.y = gy * gravityFlip;
  }
  window.addEventListener('deviceorientation', handleTilt, true);

  // Desktop/touch fallback
  let dragging = false;
  canvas.addEventListener('pointerdown', () => dragging = true);
  canvas.addEventListener('pointerup',   () => dragging = false);
  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const r = canvas.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const gx = e.clientX - cx, gy = e.clientY - cy;
    const m = Math.hypot(gx, gy) || 1;
    g.x = (gx/m) * gravityFlip;
    g.y = (gy/m) * gravityFlip;
  });

  // Double‑tap to flip gravity
  let lastTap = 0;
  canvas.addEventListener('touchend', () => {
    const now = performance.now();
    if (now - lastTap < 300) { gravityFlip *= -1; }
    lastTap = now;
  });

  // Particles
  const p = new Array(N).fill(0).map(()=> ({ x:0,y:0,vx:0,vy:0 }));
  function seedTop(){
    let i=0;
    while(i<N){
      const cols = 18, spacing = PR*1.9;
      const row = Math.floor(i/cols);
      const col = i % cols;
      p[i].x = minX + 20 + col*spacing;
      p[i].y = minY + 30 + row*spacing*0.9;
      p[i].vx = p[i].vy = 0;
      i++;
    }
  }
  seedTop();

  function collideWalls(pi){
    if (pi.x < minX+PR){ pi.x = minX+PR; pi.vx *= -0.2; }
    if (pi.x > maxX-PR){ pi.x = maxX-PR; pi.vx *= -0.2; }
    if (pi.y < minY+PR){ pi.y = minY+PR; pi.vy *= -0.2; }
    if (pi.y > maxY-PR){ pi.y = maxY-PR; pi.vy *= -0.2; }
  }
  function collideBars(pi){
    for (let b of bars){
      const x1=b[0], y1=b[1], x2=b[2], y2=b[3];
      const dx = x2-x1, dy = y2-y1;
      const L2 = dx*dx + dy*dy;
      let t = ((pi.x-x1)*dx + (pi.y-y1)*dy) / L2;
      t = Math.max(0, Math.min(1, t));
      const cx = x1 + t*dx, cy = y1 + t*dy;
      const nx = pi.x - cx, ny = pi.y - cy;
      const dist = Math.hypot(nx, ny);
      if (dist < PR+3){
        const push = (PR+3 - dist) + 0.01;
        const ux = (nx || 1e-6)/ (dist || 1e-6);
        const uy = (ny || 1e-6)/ (dist || 1e-6);
        pi.x += ux*push;
        pi.y += uy*push;
        pi.vx = pi.vx*(1 - WALL_FRICTION) + (-uy)*BOUNCE*0.01;
        pi.vy = pi.vy*(1 - WALL_FRICTION) + (ux)*BOUNCE*0.01;
      }
    }
    for (let peg of pegs){
      const nx = pi.x - peg.x, ny = pi.y - peg.y;
      const dist = Math.hypot(nx, ny);
      const R = peg.r + PR;
      if (dist < R){
        const push = (R - dist) + 0.01;
        const ux = (nx || 1e-6)/(dist || 1e-6);
        const uy = (ny || 1e-6)/(dist || 1e-6);
        pi.x += ux*push;
        pi.y += uy*push;
        pi.vx = pi.vx*(1 - WALL_FRICTION) + (ux)*BOUNCE*0.02;
        pi.vy = pi.vy*(1 - WALL_FRICTION) + (uy)*BOUNCE*0.02;
      }
    }
  }

  let last = performance.now();
  function step(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    // Pairwise interactions
    for (let i=0;i<N;i++){
      const pi = p[i];
      for (let j=i+1;j<N;j++){
        const pj = p[j];
        let dx = pj.x - pi.x, dy = pj.y - pi.y;
        const d = Math.hypot(dx, dy) || 1e-6;
        if (d < SR){
          const n = 1 - (d/SR);
          const rep = REPULSION * Math.max(0, (PR*1.6 - d)/PR*1.6);
          const coh = COHESION * n * 10;
          const rvx = pj.vx - pi.vx, rvy = pj.vy - pi.vy;
          const visc = VISCOSITY * n;
          const ux = dx/d, uy = dy/d;
          const fx = (ux * (coh - rep) + rvx * (-visc));
          const fy = (uy * (coh - rep) + rvy * (-visc));
          pi.vx -= fx*dt; pi.vy -= fy*dt;
          pj.vx += fx*dt; pj.vy += fy*dt;
        }
      }
    }

    for (let i=0;i<N;i++){
      const pi = p[i];
      pi.vx += g.x * G0 * dt;
      pi.vy += g.y * G0 * dt;
      pi.vx *= (1 - AIR_DRAG * dt);
      pi.vy *= (1 - AIR_DRAG * dt);
      pi.x += pi.vx * dt;
      pi.y += pi.vy * dt;
      collideBars(pi);
      collideWalls(pi);
    }

    render();
    requestAnimationFrame(step);
  }

  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    // Rim
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--rim').trim();
    roundRect(ctx, RIM/2, RIM/2, W-RIM, H-RIM, 26); ctx.fill();
    // Glass
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--glass-red').trim();
    roundRect(ctx, RIM/2 + GLASS, RIM/2 + GLASS, W-RIM-GLASS*2, H-RIM-GLASS*2, 20); ctx.fill();
    // Obstacles
    ctx.lineWidth = 6; ctx.lineCap='round'; ctx.strokeStyle='#fff';
    for (let b of bars){ ctx.beginPath(); ctx.moveTo(b[0],b[1]); ctx.lineTo(b[2],b[3]); ctx.stroke(); }
    ctx.fillStyle='#fff';
    for (let k of pegs){ ctx.beginPath(); ctx.arc(k.x,k.y,k.r,0,Math.PI*2); ctx.fill(); }
    // Fluid
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--oil').trim();
    ctx.strokeStyle = 'rgba(0,0,0,0.22)';
    for (let i=0;i<N;i++){
      const pi=p[i]; ctx.beginPath(); ctx.arc(pi.x,pi.y,PR,0,Math.PI*2); ctx.fill(); ctx.lineWidth=1; ctx.stroke();
    }
  }
  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // UI
  const fsBtn=document.getElementById('fsBtn');
  fsBtn.addEventListener('click', async ()=>{
    const el=document.documentElement;
    if(!document.fullscreenElement){ await el.requestFullscreen?.(); fsBtn.textContent='Exit Fullscreen'; }
    else{ await document.exitFullscreen?.(); fsBtn.textContent='Enter Fullscreen'; }
  });
  document.getElementById('resetBtn').addEventListener('click', seedTop);
  document.addEventListener('fullscreenchange', ()=>{
    fsBtn.textContent = document.fullscreenElement ? 'Exit Fullscreen' : 'Enter Fullscreen';
  });

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
